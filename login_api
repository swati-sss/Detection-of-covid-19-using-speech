//
//  Compass.swift
//  compass_sdk_ios
//
//  Created by Rakesh Shetty on 2/17/23.
//

import Combine
import CoreData
import UIKit
import os.log
import WebKit
import SwiftUI
@_implementationOnly import IPSFramework

public class Compass: UIViewController {
    private var viewModel: CompassViewModelType!
    internal let serviceLocator: ServiceLocatorType!
    private var cancellables = Set<AnyCancellable>()
    private var capabilities: [CompassCapability] = []
    private var isMapInitialized: Bool? {
        didSet {
            guard isMapInitialized == true else {
                Analytics.mapInitialization(
                    payload: BaseAnalytics(success: isMapInitialized,
                                           errorCode: EventType.errorCode.rawValue,
                                           errorMessage: EventType.errorMessage.rawValue)
                )
                return
            }
            Analytics.mapInitialization(
                payload: BaseAnalytics(success: isMapInitialized)
            )
        }
    }

    public var isFinishedInitialize = CurrentValueSubject<Bool?, Never>(nil)
    public var isFinishedSettingMap = CurrentValueSubject<Bool, Never>(false)
    public var currentStore: Int?

    private var originalStoreConfig: StoreConfig?
    private var hasAppliedOverrides = false
    
    /// Initialize the Compass class.
    /// This is use to create view model.
    public init() {
        self.serviceLocator = ServiceLocator.shared
        self.viewModel = CompassViewModel(serviceLocator: serviceLocator)
        super.init(nibName: nil, bundle: nil)
    }

    internal init(serviceLocator: ServiceLocatorType, viewModel: CompassViewModelType) {
        self.serviceLocator = serviceLocator
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    /// Handle the events for background URL session.
    /// - Parameters:
    ///   - identifier: The identifier for the background url session.
    ///   - application: The current application instance.
    public static func handleEventsForBackgroundURLSession(identifier: String, application: UIApplication) {
        _ = IPSCore.application(application,
                            handleEventsForBackgroundURLSession: identifier,
                            completionHandler: {})
    }

    /// Called when the view has appeared. Starts the position session.
    /// - Parameter animated: Wether the appearance is animated.
    public override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        viewModel.startPositionSession()
    }

    /// Initialize the Compass with authentication and configuration paramaters.
    /// - Parameters:
    ///   - authParameter: The authentication parameter to use.
    ///   - configuration: The configuration settings to apply.
    ///   - rootViewController: The root view controller to use
    public func initialize(authParameter: AuthParameter,
                           configuration: Configuration,
                           capabilities: [CompassCapability],
                           rootViewController: UIViewController) {
        var authParameter = authParameter
        self.currentStore = configuration.site
        self.capabilities = capabilities
        viewModel.rootViewController =  rootViewController
        authParameter.tokenType = authParameter.tokenType.lowercased()
        Log.info("""
                Start initialize API with authParameter: \(authParameter)
                configuration: \(configuration)
                rootViewController: \(rootViewController)
                compassVersion: \(DeviceInformation.getCompassSDKVersion())
                oriientVersion: \(DeviceInformation.getOriientSDKVersion())
                """)
        Analytics.initialization(state: .start)
        rootViewController.add(childVC: self)
        viewModel.toggleMockUser(configuration.mockUser)
        Analytics.anonymizedUserID = configuration.anonymizedUserID
        resetOverrideTracking()
        if currentStore != configuration.site {
            UserDefaults.standard.removeObject(forKey: "FeatureFlagOverrides_\(configuration.site)")
        }
        beginInitialization(authParameter: authParameter, configuration: configuration)
    }

    /// Display the map with specific workflow.
    ///
    /// - Parameters:
    ///   - workflow: The workflow to use for displaying the map.
    public func displayMap(workflow: Workflow?) {
        Log.info("Start displayMap API")
        Analytics.workflow = workflow
        DispatchQueue.main.async {
            self.viewModel.displayMap()
        }
    }

    /// Update the event with a given compass event.
    ///
    /// - Parameters:
    ///   - compassEvent: The compass event to update.
    public func updateEvent(compassEvent: CompassEvent) {
        Log.info("Start updateEvent API with compassEvent: \(compassEvent)")
        viewModel.updateEvent(compassEvent: compassEvent)
    }

    public func updateEventList(namespace: String, eventType: String, eventValue: String, metaData: HashMap? = nil) {
        Log.info("""
                  Start updateEventList API with namespace: \(namespace)
                  eventType: \(eventType)
                  eventValue: \(eventValue)
                  metaData:\(String(describing: metaData))
                  """)

        viewModel.updateEventList(
            namespace: namespace,
            eventType: eventType,
            eventValue: eventValue,
            metaData: metaData
        )
    }

    /// Displays pins on the map with the given UUID list and configuration.
    ///
    /// - Parameters:
    ///   - uuidList: The list of UUIDs representing the assets or generic IDs
    ///   - idType: The type of ID used for the UUIDs.
    ///   - config: The configuration to apply for displaying the pins.
    public func displayPin(uuidList: [String], idType: PinDropMethod, config: HashMap? = nil) {
        Log.info("Start displayPin: \(uuidList) type: \(idType) config: \(String(describing: config))")
        viewModel.displayPin(uuidList: uuidList, idType: idType, config: DisplayPinConfig(hashMap: config))
    }

    /// Displays pins on the map with the given pins and configuration.
    ///
    /// - Parameters:
    ///   - pins: The list of pins representing the AislePins which contain type, id and location.
    ///   - config: The configuration to apply for the Pins.
    public func displayPinV2(pins: [AislePin], config: HashMap? = nil, isZoomOutRequired: Bool = false) {
        Log.info("Start displayPinV2 API with aisle pins: \(pins), config: \(String(describing: config)), isZoomOutRequired: \(isZoomOutRequired)")
        viewModel.displayPinV2(pins: pins, config: DisplayPinConfig(hashMap: config), isZoomOutRequired: isZoomOutRequired)
    }

    /// Get user disctance on the map from user locatio with the given pins.
    ///
    /// - Parameters:
    ///   - pins: The list of pins representing the AislePins which contain type, id and location.
    public func getUserDistance(pins: [AislePin], completion: UserDistanceCompleteHandler? = nil) {
        Log.info("Start getUserDistance API with aisle pins: \(pins)")
        viewModel.getUserDistance(pins: pins, completion: completion)
    }

    /// Clear the map with given configuration parmater.
    ///
    /// - Parameters:
    ///   - configuration: The configration to apply for clearing the map.
    public func clearMap(configuration: HashMap? = nil) {
        Log.info("Start clearMap API with config:\(String(describing: configuration))")
        viewModel.clearMap(mapConfig: MapConfig(hashMap: configuration))
    }

    /// Get aisle location on map with given ID.
    ///
    /// - Parameters:
    ///   - id: The id to get aisle location.
    public func getAisle(id: String) {
        Log.info("Start getAisle API with id:\(id)")
        viewModel.getAisle(id: id)
    }

    /// Get status of the compass service.
    /// - Returns: A StatusService indicating the status of the compass service.
    public func getStatusService() -> StatusService {
        serviceLocator.getStatusService()
    }

    /// Set Environment to NetworkManager.
    /// - Parameter environment: The environment to apply for NetworkManager.
    public func setEnvironment(_ environment: CompassEnvironment) {
        Log.info("Setting environment to: \(environment.rawValue)")
        NetworkManager.environment = environment
    }

    /// Update Authentication with given token, consumer and account paramaters.
    ///
    /// - Parameters:
    ///   - token: The Authentication token to be used for API cals..
    ///   - tokenType: The type of the token, typically indicating user or IAM from client application.
    ///   - consumerID: The Id representing the consumer of the API, often used for identifying the client application.
    ///   - accountID: The ID of the account associate with the current user or seesion.
    public func updateAuthParams(token: String, tokenType: String, consumerID: String, accountID: String) {
        Log.info("Updating auth parameters for consumerID: \(consumerID)")
        let tokenType = tokenType.lowercased()
        guard tokenType == TokenType.User.rawValue || tokenType == TokenType.Pingfed.rawValue else {
            return
        }

        let authParameter = AuthParameter(authToken: token,
                                          tokenType: tokenType,
                                          accountID: accountID,
                                          consumerID: consumerID)
        try? serviceLocator.getKeychainService().saveToken(authParameter)
    }

    ///  Use this function to refresh the compass position or reset it when needed.
    public func resetPositionStatusEvent() {
        viewModel.resetPositionStatusEvent()
    }

    ///  Use this function to remove all the compass reference.i
    public func killSwitch() {
        viewModel.killSwitch()
    }

    deinit {
        Log.info("Releasing compass instance.")
    }

    // Get the current store configuration
    public func getCurrentStoreConfig() -> [String: Any]? {
        guard let assetService = serviceLocator.getAssetService() as? AssetServiceImpl else { return nil }
        
        // Use original config if available, otherwise current
        let storeConfig = assetService.lastStoreConfig
        
        var config: [String: Any] = [:]
        
        if let storeConfig = storeConfig {
            config["bluedotEnabled"] = storeConfig.bluedotEnabled ?? false
            //config["bluedotDisplayed"] = storeConfig.bluedotDisplayed ?? false
            config["dynamicMapEnabled"] = storeConfig.dynamicMapEnabled ?? false
            config["zoomControlEnabled"] = storeConfig.zoomControlEnabled ?? false
            config["errorScreensEnabled"] = storeConfig.errorScreensEnabled ?? false
            config["dynamicMapRotationEnabled"] = storeConfig.dynamicMapRotationEnabled ?? false
            config["spinnerEnabled"] = storeConfig.spinnerEnabled ?? false
            config["useBackgroundService"] = storeConfig.useBackgroundService ?? false
            config["backgroundServiceTimeout"] = storeConfig.backgroundServiceTimeout ?? 300.0
            config["geoFenceCheckTimeout"] = storeConfig.geoFenceCheckTimeout ?? 1.0
            config["positioningSessionTimeout"] = storeConfig.positioningSessionTimeout ?? 1.0
            config["geofenceRadius"] = storeConfig.geofenceRadius ?? 0.0
            config["sessionRefreshTime"] = storeConfig.sessionRefreshTime ?? 900
            config["heartbeatInterval"] = storeConfig.heartbeatInterval ?? 300000.0
            config["batchInterval"] = storeConfig.batchInterval ?? 60000.0
        }
        
        return config
    }

    // Apply feature flag overrides for testing
    public func applyFeatureFlagOverrides(_ overrides: [String: Any]) {
        guard let assetService = serviceLocator.getAssetService() as? AssetServiceImpl,
              var storeConfig = assetService.lastStoreConfig else { return }
        
        // Store original config if this is the first override
        if !hasAppliedOverrides {
            originalStoreConfig = storeConfig
            hasAppliedOverrides = true
        }
        
        // Apply overrides
        if let bluedotEnabled = overrides["bluedotEnabled"] as? Bool {
            storeConfig.bluedotEnabled = bluedotEnabled
            storeConfig.bluedotDisplayed = bluedotEnabled
        }
//        if let bluedotDisplayed = overrides["bluedotDisplayed"] as? Bool {
//            storeConfig.bluedotDisplayed = bluedotDisplayed
//        }
        if let dynamicMapEnabled = overrides["dynamicMapEnabled"] as? Bool {
            storeConfig.dynamicMapEnabled = dynamicMapEnabled
        }
        if let zoomControlEnabled = overrides["zoomControlEnabled"] as? Bool {
            storeConfig.zoomControlEnabled = zoomControlEnabled
        }
        if let errorScreensEnabled = overrides["errorScreensEnabled"] as? Bool {
            storeConfig.errorScreensEnabled = errorScreensEnabled
        }
        if let dynamicMapRotationEnabled = overrides["dynamicMapRotationEnabled"] as? Bool {
            storeConfig.dynamicMapRotationEnabled = dynamicMapRotationEnabled
        }
        if let spinnerEnabled = overrides["spinnerEnabled"] as? Bool {
            storeConfig.spinnerEnabled = spinnerEnabled
        }
        if let useBackgroundService = overrides["useBackgroundService"] as? Bool {
            storeConfig.useBackgroundService = useBackgroundService
        }
        if let backgroundServiceTimeout = overrides["backgroundServiceTimeout"] as? Double {
            storeConfig.backgroundServiceTimeout = backgroundServiceTimeout
        }
        if let geoFenceCheckTimeout = overrides["geoFenceCheckTimeout"] as? Double {
            storeConfig.geoFenceCheckTimeout = geoFenceCheckTimeout
        }
        if let positioningSessionTimeout = overrides["positioningSessionTimeout"] as? Double {
            storeConfig.positioningSessionTimeout = positioningSessionTimeout
        }
        if let sessionRefreshTime = overrides["sessionRefreshTime"] as? Int {
            storeConfig.sessionRefreshTime = sessionRefreshTime
        }
        
        assetService.lastStoreConfig = storeConfig
        
        viewModel.updateStoreConfiguration(storeConfig)
    }

    // Revert to original backend configuration
    public func revertToOriginalConfig() {
        guard let originalConfig = originalStoreConfig,
              let assetService = serviceLocator.getAssetService() as? AssetServiceImpl else { return }
        
        assetService.lastStoreConfig = originalConfig
        viewModel.updateStoreConfiguration(originalConfig)
        
        hasAppliedOverrides = false
        originalStoreConfig = nil
    }

    // Check if overrides are currently applied
    public func hasOverridesApplied() -> Bool {
        return hasAppliedOverrides
    }

    // Reset all override tracking, called on new initialization
    public func resetOverrideTracking() {
        hasAppliedOverrides = false
        originalStoreConfig = nil
    }
}

private extension Compass {
    /// Beign the initialization process with provided authentication parameters and configuration.
    /// - Parameters:
    ///   - authParameter: The authentication parameter needed for initialization.
    ///   - configuration: The configuration settings for initialization.
    func beginInitialization(authParameter: AuthParameter, configuration: Configuration) {
        // Validate configuration before proceeding
        guard validateConfiguration(configuration) else { return }

        // Fetch the access token and proceed with the initialization process
        viewModel.getAccessToken(authParameter: authParameter)
            .flatMap { [weak self] accessTokenResponse -> AnyPublisher<StoreConfig?, Never> in
                Log.info("AccessTokenResponse: \(String(describing: accessTokenResponse))")
                accessTokenResponse == nil ?
                Analytics.telemetry(
                    payload: TelemetryAnalytics(
                        isError: true,
                        event: CommonErrors.ERROR_INVALID_AUTH.rawValue,
                        context: CommonErrors.ErrorContext.CONTEXT_INIT.rawValue
                    )
                ) : nil
                return self?.fetchConfigurationDetails(configuration: configuration) ?? Empty().eraseToAnyPublisher()
            }
            .flatMap { [weak self] storeConfig -> AnyPublisher<Bool, Never> in
                guard let self else { return Empty().eraseToAnyPublisher() }
                if self.capabilities.contains(.storeMap) {
                    return self.validateAndUpdateStoreConfig(storeConfig)
                        .flatMap { [weak self ] _ -> AnyPublisher<Void, Never> in
                            Log.info("Deleting EventStoreService Event")
                            return self?.deleteAllEvents() ?? Empty().eraseToAnyPublisher()
                        }
                        .flatMap { [weak self] _ -> AnyPublisher<Bool, Never> in
                            self?.completeInitialization() ?? Empty().eraseToAnyPublisher()
                        }.eraseToAnyPublisher()
                }

                if capabilities.contains(.productEnrollment) {
                    self.serviceLocator.getImageUploader().startUploads()
                    self.isFinishedInitialize.value = true
                }

                return Just(true).eraseToAnyPublisher()
            }
            .sink { [weak self] isFinishedInitialize in
                guard isFinishedInitialize else {
                    return
                }

                Log.info("Finished fetching map. Map is ready to load.")
                self?.isFinishedSettingMap.value = true
                // Set map initialization flag
                self?.isMapInitialized = true
            }.store(in: &cancellables)
    }

    /// Validates the provided configuration.
    /// - Parameter configuration: The configuration to validate.
    /// - Returns: A Boolean indicating whether the condiguration is valid.
    private func validateConfiguration(_ configuration: Configuration) -> Bool {
        guard configuration.site != 0 else {
            Log.warning("Configuration is not valid")
            Analytics.telemetry(
                payload: TelemetryAnalytics(
                    isError: true,
                    event: CommonErrors.ERROR_CONFIG_NOT_INITIALIZED.rawValue,
                    context: CommonErrors.ErrorContext.CONTEXT_INIT.rawValue
                )
            )
            isFinishedInitialize.value = false
            isMapInitialized = false
            return false
        }
        return true
    }

    /// Fetch the configurstion details for the provided configuration.
    /// - Parameter configuration: The configuration settings to fetch details for.
    /// - Returns: A publisher that outputs the store configuration details.
    func fetchConfigurationDetails(configuration: Configuration) -> AnyPublisher<StoreConfig?, Never> {
        return fetchConfiguration(for: String(configuration.site))
        .flatMap { [weak self] configResponse -> AnyPublisher<StoreConfig?, Never> in
            guard let self else {
                Analytics.telemetry(payload: TelemetryAnalytics(
                    isError: true,
                    event: Init.INIT_ERROR_CONFIG_AUTH.rawValue
                ))
                return Empty(completeImmediately: true).eraseToAnyPublisher()
            }
            Analytics.telemetry(payload: TelemetryAnalytics(event: Init.INIT_CONFIG_FETCHED.rawValue))
            return self.saveConfiguration(configuration)
                .flatMap { _ in
                    return Just(configResponse?.storeConfig).eraseToAnyPublisher()
                }.eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    /// Validates the store configuration and updates if valid.
    /// - Parameter storeConfig: The store configuration to valiidate and update.
    /// - Returns: A publisher that completes when the store configuration is updated.
    private func validateAndUpdateStoreConfig(_ storeConfig: StoreConfig?) -> AnyPublisher<Void, Never> {
        guard let storeConfig, let valid = storeConfig.valid, valid else {
            Log.warning("Payload storeConfig is not valid")
            Analytics.telemetry(
                payload: TelemetryAnalytics(
                    isError: true,
                    event: CommonErrors.ERROR_NOT_INITIALIZED.rawValue,
                    context: CommonErrors.ErrorContext.CONTEXT_INIT.rawValue
                )
            )
            isFinishedInitialize.value = false
            return Empty().eraseToAnyPublisher()
        }

        Log.info("StoreConfig: \(storeConfig)")
        return viewModel.updateStoreConfiguration(storeConfig)
    }

    /// Complete the initalization process.
    /// - Returns: A publisher that completes when the initialization is completed.
    private func completeInitialization() -> AnyPublisher<Bool, Never> {
        guard self.children.isEmpty else {
            return Empty().eraseToAnyPublisher()
        }

        Log.info("Finished initializing API, now  fetching map.")
        Analytics.initialization(state: .finish)
        self.isFinishedInitialize.value = true
        return self.viewModel.isMapViewReady()
    }

    /// Will also retrieve configuration based on storeId, consumerId, timestamp and access token.
    ///
    /// - Parameters:
    ///   - storeId: The storeId to be used to get configuration
    ///   - consumerId: The consumerId to be used to get configuration
    ///   - timestamp: The timestamp to be used to get configuration
    ///   - accessTokenResponse: The accessTokenResponse to be used to get configuration
    func fetchConfiguration(for storeId: String) -> AnyPublisher<ConfigurationPayload?, Never> {
        serviceLocator.getConfigurationService()
            .getConfigData(for: storeId)
            .retry()
            .catch { [weak self] error -> AnyPublisher<ConfigurationPayload?, Error> in
                Log.error(error)
                guard let error = error as? ErrorResponse else {
                    return Fail(error: error).eraseToAnyPublisher()
                }

                self?.serviceLocator.getStatusService()
                    .emitErrorStatusEvent(for: error, isInitError: true)
                return Fail(error: error).eraseToAnyPublisher()
            }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    func saveConfiguration(_ configuration: Configuration) -> AnyPublisher<ConfigurationDataModel, Never> {
        serviceLocator.getConfigurationStoreService().setConfiguration(configuration)
            .retry()
            .catch { [weak self] error -> AnyPublisher<ConfigurationDataModel, Never> in
                Log.error(error)
                self?.isFinishedInitialize.value = false
                return Empty().eraseToAnyPublisher()
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    func deleteAllEvents() -> AnyPublisher<Void, Never> {
        serviceLocator.getEventStoreService().deleteAllEvents()
            .retry()
            .catch { error -> AnyPublisher<Void, Error> in
                Log.error("Fail to delete EventStoreService Event from Core Database \(error.localizedDescription)")
                return Just.void()
            }
            .replaceError(with: ())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
