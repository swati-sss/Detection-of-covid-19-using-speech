Here’s how the sample app turns the SDK’s geofence signal into a local iOS notification:

  1. Permission setup – When the app launches, SampleApp calls NotificationManager.shared.configure(). That just asks the user for alert/sound permission
     (UNUserNotificationCenter).
  2. Listening to Compass events – After you initialize Compass, HomeViewModel.waitForEventEmitterCompletionHandlerResponse sets itself as the status service’s event handler. The
     SDK emits different event types there (map status, bootstrap, errors… and geofence).
  3. Catching geofence changes – When a .geofenceStateEventEmitter shows up, we cast it to GeofenceStateEventEmitter and read state (“inside”, “outside”, etc.).
  4. Detecting transitions – We track the last known state in currentGeoFenceState. Only when the new state differs do we react (so you don’t spam notifications on duplicate
     events).
      - If you go from outside → inside (or undefined → inside when the app first learns your location), we call sendGeoFenceEnteredNotification().
      - If you move inside → outside, we fire sendGeoFenceExitedNotification().
  5. Posting the notification – Those helper methods call NotificationManager.shared.post(...), which schedules a local notification immediately (0.25s trigger) using
     UNUserNotificationCenter.
  6. Optional logging – We also write a message to the sample app console (consoleLog("**** ENTERED GEOFENCE…")) so you can see it while testing.

  No extra SDK work was needed—the Compass SDK already emits the geofence event. The sample app simply listens for that event, compares it to the previous state, and pushes a
  standard iOS local notification whenever the state flips.
