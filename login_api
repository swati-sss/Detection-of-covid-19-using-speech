import Foundation

extension StoreMapLoaderViewModel {
    func request(_ message: MessageRequest, timeInterval: TimeInterval = StoreMapConfig.zoomPinAnimationDelay) {
        guard let webView = self.mapViewDelegate?.webView else {
            return
        }

        self.messageSender.send(message, in: webView)
    }

    func refreshWebView() {
        renderedPins = []
        renderedPinsZoomRect = nil
        hasLoadedMapView = false
        mapViewDelegate?.reloadWebView()
        Log.debug("Refresh WebView")
    }

    func handle(_ message: MessageResponse, completion: ((MessageResponse) -> Void)? = nil) {
        switch message {
        case .mapData(let mapData):
            handleMapDataResponse(mapData)
        case .mapLoaded(let mapLoaded):
            handleMapLoadedResponse(mapLoaded)
        case .coordinateSpaceDiscoveryTap(let coordinateSpaceDiscoveryTap):
            handleCoordinateSpaceDiscoveryTap(coordinateSpaceDiscoveryTap)
        case .pinRenderedMessage(let pinRenderedMessage):
            self.handlePinRenderedMessage(pinRenderedMessage)
        case let .pinXYRenderedMessage(message):
            self.handlePinXYRenderedMessage(message)
        case let .pinsActionAlleyRenderedResponse(message):
            handlePinsActionAlleyRenderedResponse(message)
        case let .userLocationRenderedMessage(userLocationRenderedMessage):
            handleUserLocationRenderedMessage(userLocationRenderedMessage)
        case let .pinClicked(pinClicked):
            handlePinClicked(pinClicked)
        default:
            Log.warning("Unhandled message type: \(message)")
        }
        completion?(message)
    }

    private func handleMapDataResponse(_ mapData: MapData) {
        mapDataReadyRequestTimer?.invalidate()
        mapDataReadyRequestTimer = nil
        self.mapData = mapData
    }

    private func handleMapLoadedResponse(_ mapLoaded: MapLoaded) {
        mapLoadedData = mapLoaded
        mapViewDelegate?.setLoadingVisible(true)
        // Loading this particular map version is needed for POI_CLICKED click event or it wont work
        request(.version(VersionRequest(version: StoreMapConfig.webAppVersion)))
        startTimerForMapDataReadyRequest()
        request(.mapData)
        renderPinsIfNeeded(floorCount: mapLoaded.floors.count)
        request(.coordinateSpaceDiscoveryTapRequested(CoordinateSpaceDiscoveryTapRequest(enabled: true)))

        Log.debug("Coordinate Space Discovery Tap Requested is enabled")
        statusService.emitMapStatusEvent(isSuccess: true)
        removeUserPositionIndicator()
        mapViewDelegate?.setFloorControlsVisible(mapLoaded.floors.count > 1)
    }

    private func handleCoordinateSpaceDiscoveryTap(_ coordinateSpaceDiscoveryTap: CoordinateSpaceDiscoveryTap) {
        Log.debug("onMapLongPressed is called with coordinateSpaceDiscoveryTap: \(coordinateSpaceDiscoveryTap)")
        onMapLongPressed(coordPayLoad: coordinateSpaceDiscoveryTap)
    }

    private func handlePinsActionAlleyRenderedResponse(_ message: PinRenderedMessage) {
        Log.debug("pinsActionAlleyRenderedResponse with message: \(message)")
        zoomOnLocation(topLeft: message.topLeft, bottomRight: message.bottomRight)
    }

    private func handleUserLocationRenderedMessage(_ userLocationRenderedMessage: UserLocationRenderedMessage) {
        Log.debug("userLocationRenderedMessage with message: \(userLocationRenderedMessage)")
        zoomOnLocation(
            topLeft: userLocationRenderedMessage.topLeft,
            bottomRight: userLocationRenderedMessage.bottomRight,
            target: .userLocation
        )
    }

    private func handlePinClicked(_ pinClicked: PinClicked) {
        Log.debug("pinClicked with message: \(pinClicked)")
        statusService.emitPinClickedEvent(
            zone: pinClicked.data.zone,
            aisle: pinClicked.data.aisle,
            section: pinClicked.data.section
        )
    }

    func startTimerForMapDataReadyRequest() {
        mapDataReadyRequestTimer = .scheduledTimer(withTimeInterval: StoreMapConfig.apiTimeoutLimit,
                                                   repeats: false) { [weak self] _ in
            self?.mapDataReadyRequestTimer?.invalidate()
            self?.mapDataReadyRequestTimer = nil
            Log.error(StoreMapError.mapLoadTimedOut)
        }
    }

    func renderPinsIfNeeded(floorCount: Int) {
        defer {
            hasLoadedMapView = true
            mapFocusManager.isMapViewPresent.value = true
            indoorPositioningService.registerApplicationEvent(.mapPresented)
        }
        guard !hasLoadedMapView else { return }
        if !renderedPins.isEmpty, floorCount > 1 {
            request(.aisleData)
        }

        if let pin = configuration.pin, floorCount == 1 {
            var pinsToBeRendered = renderedPins
            pinsToBeRendered.append(pin)
            render(pinsToBeRendered)
        }
    }
}

// MARK: - View & Message Lifecycle
extension StoreMapLoaderViewModel {
    func viewDidAppear() {
        guard blueDotMode != .none, hasLoadedMapView else { return }
        mapFocusManager.isMapViewPresent.value = true
        indoorPositioningService.registerApplicationEvent(.mapPresented)
    }

    func viewWillDisappear() {
        guard blueDotMode != .none else { return }
        mapFocusManager.isMapViewPresent.value = false
        indoorPositioningService.registerApplicationEvent(.mapHidden)
    }

    func didConstructView() {
        refreshWebView()
        setupNavigationPaths()
    }

    func didLoadWebView() {
        zoomToPinsIfNeeded()

        guard let webView = mapViewDelegate?.webView else { return }
        zoomAnalyticsLogger?.updateZoomScale(zoomScale: webView.scrollView.zoomScale)
    }

    func handleError() {
        statusService.emitMapStatusEvent(isSuccess: false)
    }

    func onStoreMapFloorChange(levelType: FloorLevelType, _ completion: (() -> Void)?) {
        guard (mapViewDelegate?.webView) != nil else { return }
        floorSelected = levelType == .floorOne ? 0 : 1
        request(.floorLevelChange((FloorLevelChangeRequest(floor: levelType.rawValue))))
    }

    func getMapURLRequest() -> URLRequest? {
        let urlString = APIPath.storeMapAPI.replacingOccurrences(
            of: RequestIdentifier.storeId.rawValue,
            with: "\(assetService.storeId)",
            options: .literal,
            range: nil)
        guard let url = URL(string: urlString) else {
            Log.warning("Cannot load Web View")
            return nil
        }
        var request = URLRequest(url: url)
        APIHelper.getStandardRequestHeaders(keychainService: keychainService).forEach { (key, value) in
            request.setValue(value, forHTTPHeaderField: key)
        }
        return request
    }

    func messageParser(_ messageParser: MessageParsing, didParseMessageResponse message: MessageResponse) {
        Log.debug("Webview message received: \(message)")
        handle(message)
    }

    func messageParser(_ messageParser: MessageParsing, didFailWithError error: StoreMapDecodingError) {
        Log.error("Error occurred while parsing message: \(error)")
        guard let defaultValue = error.defaultValue else { return }
        handle(defaultValue)
    }

    func removeUserPositionIndicator() {
        let clearPos = UserPosition(x: -1, y: -1, ringRadius: nil)
        request(.showUserLocation(clearPos))
    }
}
