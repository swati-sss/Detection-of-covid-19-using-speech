import WebKit
import Combine
@_implementationOnly import LivingDesign

typealias StoreMapsCompletion = () -> Void

enum ZoomActionType {
    case zoomIn
    case zoomOut
}

enum FloorLevelType: String {
    case floorOne = "1"
    case floorTwo = "2"
}

enum StoreMapError: Error {
    case invalidStatusCode(Int)
    case invalidResponse
    case failedToLoadContent(Error)
    case mapLoadTimedOut
    case noInternetConnection(Error)
}

private enum MapButtonColor {
    static let blue = UIColor(red: 0, green: 0.44, blue: 0.86, alpha: 1)
    static let black = UIColor.black
    static let gray = UIColor(red: 0.73, green: 0.73, blue: 0.75, alpha: 1)
}

protocol StoreMapsViewDelegate: AnyObject {
    var webView: WKWebView { get }
    var isWebViewLoaded: Bool { get set}
    var isCenterButtonClicked: Bool { get set}
    var isLocationStatusVisible: Bool { get set }
    var mapCenterButton: LivingDesign.LDIconButton { get set}
    var zoomControlStackView: UIStackView { get set}
    var floorControlStackView: UIStackView { get set}

    func zoomOnRegion(with rect: CGRect, zoomAnimationDelay: TimeInterval, completion: StoreMapsCompletion?)
    func toggleLoadingView(_ shouldShow: Bool)
    func reloadWebView()
    func zoomOut(with zoomScale: CGFloat?, _ completion: @escaping (() -> Void))
    func zoom(to rect: CGRect, isAnimated: Bool)
    func setZoomScale(to zoomScale: CGFloat, zoomType: ZoomActionType, _ completion: StoreMapsCompletion?)
    func handleNavigationInterruption(for index: Int, status: NavigationStatus?)
    func refreshNavigationButtonState(_ isVisible: Bool?)
    func previewSetUp(isStaticPathVisible: Bool)
    func updateZoomInteraction(enabled: Bool)
    func displayPinErrorBanner(_ enabled: Bool)
}

extension StoreMapsViewDelegate {
    func zoomOut(with zoomScale: CGFloat? = nil, _ completion: @escaping (() -> Void) = {}) {
        zoomOut(with: zoomScale, completion)
    }
}

class StoreMapView: UIView, StoreMapsViewDelegate, UIGestureRecognizerDelegate {
    struct Options {
        let dynamicMapEnabled: Bool
        let zoomControlEnabled: Bool
        let errorScreensEnabled: Bool
        let spinnerEnabled: Bool
        let dynamicMapRotationEnabled: Bool
        let navigationConfig: NavigationConfig
        let mapUiConfig: MapUiConfig
        let pinsConfig: PinsConfig
    }

    internal var options: Options
    internal var isCenterButtonClicked: Bool
    internal var isNavigationButtonClicked: Bool
    weak var webViewLoaderViewModel: StoreMapViewActionable?
    let webView: WKWebView
    private var currentIsPositionLocked: Bool?
    private var lastNavigationButtonVisibility: Bool?
    private var snackbar: LivingDesign.LDSnackbar?
    var mapCenterButton: LivingDesign.LDIconButton = {
        let button = LivingDesign.LDIconButton(
            dataModel: LivingDesign.LDIconButton.Model(
                size: .large,
                image: Asset.Image.mapCenter.image,
                color: .white,
                shape: .round
            )
        )
        button.translatesAutoresizingMaskIntoConstraints = false
        return button
    }()

    private let navigationButton: LivingDesign.LDIconButton = {
        let button = LivingDesign.LDIconButton(
            dataModel: LivingDesign.LDIconButton.Model(
                size: .large,
                image: Asset.Image.routePreviewStart.image,
                color: .default,
                shape: .round
            )
        )
        button.translatesAutoresizingMaskIntoConstraints = false
        return button
    }()

    private let buttonStackView: UIStackView = {
        let stackView = UIStackView()
        stackView.translatesAutoresizingMaskIntoConstraints = false
        stackView.axis = .vertical
        stackView.spacing = LDSpacing.space8
        stackView.alignment = .center
        return stackView
    }()

    var isLocationStatusVisible: Bool = false {
        didSet {
            locationStatusLabel.isHidden = !isLocationStatusVisible
            locationStatusContainer.isHidden = !isLocationStatusVisible
            Log.debug("Location status visibility set to: \(isLocationStatusVisible)")
        }
    }

    private let locationStatusLabel: UILabel = {
        let label = UILabel()
        label.translatesAutoresizingMaskIntoConstraints = false
        label.text = LocalizedKey.findingLocation.localized
        label.textAlignment = .left
        label.font = UIFont.bogle(ofSize: LDSpacing.space12, weight: .bold)
        label.numberOfLines = 0
        label.textColor = .white
        return label
    }()

    private let locationActivityIndicator: LivingDesign.LDSpinner = {
        let locationActivityIndicator = LDSpinner(style: .inverse, size: .large)
        locationActivityIndicator.translatesAutoresizingMaskIntoConstraints = false
        return locationActivityIndicator
    }()

    private let locationStatusContainer: UIStackView = {
        let stack = UIStackView()
        stack.translatesAutoresizingMaskIntoConstraints = false
        stack.axis = .horizontal
        stack.spacing = 8
        stack.alignment = .center
        stack.distribution = .fill
        stack.isHidden = true
        stack.backgroundColor = UIColor(red: 0, green: 0.176, blue: 0.345, alpha: 1)
        stack.layer.cornerRadius = 12
        stack.layer.masksToBounds = true
        stack.layoutMargins = UIEdgeInsets(top: 6, left: 12, bottom: 6, right: 12)
        stack.isLayoutMarginsRelativeArrangement = true
        return stack
    }()

    internal var zoomControlStackView: UIStackView = {
        let stackView = UIStackView(axis: .vertical)
        stackView.distribution = .fill
        stackView.backgroundColor = .white
        stackView.layer.cornerRadius = 5
        stackView.layer.shadowColor = UIColor.black.cgColor
        stackView.layer.shadowOpacity = 0.3
        stackView.layer.shadowOffset = CGSize(width: 1, height: 1)
        stackView.layer.shadowRadius = 5
        stackView.layer.masksToBounds = false
        return stackView
    }()

    internal var floorControlStackView: UIStackView = {
        let stackView = UIStackView(axis: .vertical)
        stackView.distribution = .equalSpacing
        stackView.backgroundColor = .white
        stackView.layer.cornerRadius = 5
        stackView.layer.shadowColor = UIColor.black.cgColor
        stackView.layer.shadowOpacity = 0.3
        stackView.layer.shadowOffset = CGSize(width: 1, height: 1)
        stackView.layer.shadowRadius = 5
        stackView.layer.masksToBounds = false
        return stackView
    }()

    internal let pinErrorBanner: LDAlert = {
        return LDAlert(dataModel: LDAlert.Model(message: NSAttributedString(string: ""), messageType: .warning))
    }()

    var floorOneButton: CustomButton?
    var floorTwoButton: CustomButton?
    private let divider = LDDivider()
    var isWebViewLoaded = false
    @Published var mapState: StoreMapState?

    public init(webViewLoaderViewModel: StoreMapViewActionable, options: Options) {
        self.webViewLoaderViewModel = webViewLoaderViewModel
        let configuration = WKWebViewConfiguration()
        let controller = WKUserContentController()
        controller.add(webViewLoaderViewModel.messageParser, name: "deviceBridge")
        configuration.userContentController = controller
        configuration.allowsInlineMediaPlayback = false
        configuration.allowsAirPlayForMediaPlayback = false
        configuration.allowsPictureInPictureMediaPlayback = false
        configuration.preferences.isFraudulentWebsiteWarningEnabled = false
        configuration.dataDetectorTypes = []

        let wkWebView = WKWebView(frame: .zero, configuration: configuration)
        wkWebView.scrollView.isDirectionalLockEnabled = false
        wkWebView.scrollView.showsHorizontalScrollIndicator = false
        wkWebView.scrollView.showsVerticalScrollIndicator = false
        wkWebView.scrollView.contentInset = .zero
        wkWebView.scrollView.contentOffset = .zero
        wkWebView.scrollView.minimumZoomScale = StoreMapZoomLevel.first.minimumZoomScale
        wkWebView.scrollView.maximumZoomScale = StoreMapZoomLevel.fourth.maximumZoomScale
        wkWebView.scrollView.scrollsToTop = false
        wkWebView.isOpaque = true
        wkWebView.accessibilityElementsHidden = false
        self.options = options
        self.isCenterButtonClicked = options.dynamicMapEnabled
        self.isNavigationButtonClicked = false
        webView = wkWebView
        super.init(frame: .zero)
        webViewLoaderViewModel.mapViewDelegate = self
        constructView()
    }

    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    deinit {
        webView.uiDelegate = nil
        webView.navigationDelegate = nil
        webView.scrollView.delegate = nil
    }

    func constructView() {
        mapCenterButton.isHidden = true
        mapCenterButton.addTarget(self, action: #selector(mapCenterButtonTapped), for: .touchUpInside)
        applyIconButtonStyle(
            mapCenterButton,
            image: Asset.Image.mapCenter.image,
            iconColor: MapButtonColor.gray,
            backgroundColor: .white
        )
        navigationButton.isHidden = true
        navigationButton.addTarget(self, action: #selector(navigationButtonTapped), for: .touchUpInside)
        applyIconButtonStyle(
            navigationButton,
            image: Asset.Image.routePreviewStart.image,
            iconColor: .white,
            backgroundColor: MapButtonColor.blue
        )
        backgroundColor = .white
        translatesAutoresizingMaskIntoConstraints = false
        webView.scrollView.contentInsetAdjustmentBehavior = .never
        webView.navigationDelegate = self
        webView.scrollView.delegate = self
        addAutoLayoutSubview(webView)
        addAutoLayoutSubview(buttonStackView)
        buttonStackView.addArrangedSubview(mapCenterButton)
        buttonStackView.addArrangedSubview(navigationButton)
        addAutoLayoutSubview(zoomControlStackView)
        addAutoLayoutSubview(floorControlStackView)
        if options.mapUiConfig.pinLocationUnavailableBannerEnabled == true {
            configurePinErrorBanner()
            addAutoLayoutSubview(pinErrorBanner)
        }
        if options.mapUiConfig.bannerEnabled == true {
            addAutoLayoutSubview(locationStatusContainer)
            locationStatusContainer.addArrangedSubview(locationActivityIndicator)
            locationStatusContainer.addArrangedSubview(locationStatusLabel)
        }
        let zoomInButton = createZoomButton(with: getZoomButtonModel(for: ButtonModel.ActionType.zoomIn))
        zoomControlStackView.addArrangedSubview(divider)
        let zoomOutButton = createZoomButton(with: getZoomButtonModel(for: ButtonModel.ActionType.zoomOut))
        floorOneButton = createFloorButton(with: getFloorButtonModel(for: ButtonModel.ActionType.floorOne))
        floorTwoButton = createFloorButton(with: getFloorButtonModel(for: ButtonModel.ActionType.floorTwo))
        floorOneButton?.isSelected = true
        floorTwoButton?.isSelected = false
        constructZoomControlConstraints(zoomInButton: zoomInButton, zoomOutButton: zoomOutButton)
        constructFloorControlConstraints()
        constructPinErrorBannerConstraints()
        constructButtonStackViewConstraints()
        constructWebViewConstraints()

        // check zoomControlEnabled feature flag
        zoomControlStackView.isHidden = !options.zoomControlEnabled
    }

    func updateZoomInteraction(enabled: Bool) {
        webView.scrollView.isUserInteractionEnabled = enabled
    }

    func constructPinErrorBannerConstraints() {
        guard options.mapUiConfig.pinLocationUnavailableBannerEnabled == true else { return }
        NSLayoutConstraint.activate([
            pinErrorBanner.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor, constant: LDSpacing.space16),
            pinErrorBanner.leadingAnchor.constraint(equalTo: safeAreaLayoutGuide.leadingAnchor, constant: LDSpacing.space16),
            pinErrorBanner.trailingAnchor.constraint(equalTo: safeAreaLayoutGuide.trailingAnchor, constant: -LDSpacing.space16)
        ])
    }

    func constructZoomControlConstraints(zoomInButton: CustomButton, zoomOutButton: CustomButton) {
        var constraints: [NSLayoutConstraint] = [
            zoomControlStackView.trailingAnchor.constraint(
                equalTo: safeAreaLayoutGuide.trailingAnchor,
                constant: -LDSpacing.space16
            ),
            zoomControlStackView.topAnchor.constraint(
                equalTo: safeAreaLayoutGuide.topAnchor,
                constant: LDSpacing.space16
            ), zoomControlStackView.widthAnchor.constraint(equalToConstant: LDSpacing.space40),
            zoomControlStackView.heightAnchor.constraint(equalToConstant: LDSpacing.space40 + LDSpacing.space40),
            zoomInButton.widthAnchor.constraint(equalToConstant: LDSpacing.space24),
            zoomInButton.heightAnchor.constraint(equalToConstant: LDSpacing.space24),
            zoomInButton.leadingAnchor.constraint(
                equalTo: zoomControlStackView.leadingAnchor),
            zoomInButton.trailingAnchor.constraint(
                equalTo: zoomControlStackView.trailingAnchor),
            divider.heightAnchor.constraint(equalToConstant: 1),
            divider.leadingAnchor.constraint(
                equalTo: zoomControlStackView.leadingAnchor,
                constant: LDSpacing.space4
            ),
            divider.trailingAnchor.constraint(
                equalTo: zoomControlStackView.trailingAnchor,
                constant: -LDSpacing.space4
            ),
            divider.centerYAnchor.constraint(
                equalTo: zoomControlStackView.centerYAnchor),
            zoomOutButton.widthAnchor.constraint(equalToConstant: LDSpacing.space24),
            zoomOutButton.heightAnchor.constraint(equalToConstant: LDSpacing.space24),
            zoomOutButton.leadingAnchor.constraint(
                equalTo: zoomControlStackView.leadingAnchor),
            zoomOutButton.trailingAnchor.constraint(
                equalTo: zoomControlStackView.trailingAnchor)
        ]
        setupLocationStatusConstraints(constraints: &constraints)
        NSLayoutConstraint.activate(constraints)
    }

    func updateLocationStatus(text: String, isLocked: Bool) {
        guard !locationStatusLabel.isHidden else { return }

        if isLocked {
            isLocationStatusVisible = false
            locationActivityIndicator.stopAnimating()
            Log.debug("Spinner stopped animating")
        } else if !locationActivityIndicator.media.isAnimating {
            locationStatusLabel.text = text
            isLocationStatusVisible = true
            locationActivityIndicator.startAnimating()
            Log.debug("Spinner started animating with status label text: \(text)")
            updateLocationStatusAfterDelay(
                text: LocalizedKey.keepHeading.localized
            )
        }
    }

    private func updateLocationStatusAfterDelay(text: String, delay: TimeInterval = 5.0) {
        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            self.locationStatusLabel.text = text
            Log.debug("Spinner started animating with status label text: \(text)")
        }
    }

    func constructFloorControlConstraints() {
        NSLayoutConstraint.activate([
            floorControlStackView.trailingAnchor.constraint(
                equalTo: safeAreaLayoutGuide.trailingAnchor,
                constant: -LDSpacing.space16
            ),
            floorControlStackView.topAnchor.constraint(
                equalTo: zoomControlStackView.bottomAnchor,
                constant: LDSpacing.space8
            ),
            floorControlStackView.widthAnchor.constraint(equalToConstant: LDSpacing.space40),
            floorControlStackView.heightAnchor.constraint(equalToConstant: LDSpacing.space40 + LDSpacing.space40)
        ])
    }

    private func constructButtonStackViewConstraints() {
        NSLayoutConstraint.activate([
            mapCenterButton.widthAnchor.constraint(equalToConstant: LDSpacing.space40),
            mapCenterButton.heightAnchor.constraint(equalToConstant: LDSpacing.space40),
            navigationButton.widthAnchor.constraint(equalToConstant: LDSpacing.space40),
            navigationButton.heightAnchor.constraint(equalToConstant: LDSpacing.space40),
            buttonStackView.trailingAnchor.constraint(
                equalTo: safeAreaLayoutGuide.trailingAnchor, constant: -LDSpacing.space16
            ),
            buttonStackView.bottomAnchor.constraint(
                equalTo: safeAreaLayoutGuide.bottomAnchor, constant: -LDSpacing.space16
            ),
            buttonStackView.widthAnchor.constraint(equalToConstant: LDSpacing.space40)
        ])
    }

    func constructWebViewConstraints() {
        NSLayoutConstraint.activate([
            webView.leadingAnchor.constraint(equalTo: safeAreaLayoutGuide.leadingAnchor),
            webView.trailingAnchor.constraint(equalTo: safeAreaLayoutGuide.trailingAnchor),
            webView.topAnchor.constraint(equalTo: safeAreaLayoutGuide.topAnchor),
            webView.bottomAnchor.constraint(equalTo: safeAreaLayoutGuide.bottomAnchor)
        ])
    }

    func reloadWebView() {
        Analytics.telemetry(payload: TelemetryAnalytics(event: DisplayMap.DISPLAY_MAP_REQUESTED.rawValue))
/*#if DEBUG
        // Add/Replace HTML file in the project bundle
        // Here, we are loading a local HTML file from bundle to test the user location focus feature on the map.
        if let filePath = Bundle.main.path(forResource: "2119", ofType: "html") {
            let contents =  try? String(contentsOfFile: filePath, encoding: .utf8)
            let baseUrl = URL(fileURLWithPath: filePath)
            webView.loadHTMLString((contents ?? "") as String, baseURL: baseUrl)
            return
        }

#endif*/
        guard let request = APIPath.customStoreMapRequest ?? webViewLoaderViewModel?.getMapURLRequest() else {
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: DisplayMap.DISPLAY_MAP_ERROR_INVALID_CONTAINER.rawValue
            ))
            return
        }
        setMapState(.loading(true))
        webView.load(request)

        disableTextSelection()

        // Extract headers from the request
        let headers = request.allHTTPHeaderFields ?? [:]
        let isCustom = (APIPath.customStoreMapRequest != nil)

        Log.info("""
                 - Request Info -
                 URL Type: \(isCustom ? "Custom" : "Default")
                 URL: \(String(describing: request.url))
                 Method: \(request.httpMethod ?? "GET")
                 Body: \(String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "nil")
                 Headers:
                 \(headers.map { "\($0.key): \($0.value)" }.joined(separator: "\n"))
                 """)
    }

    func disableTextSelection() {
        if #available(iOS 14.5, *) {
            webView.configuration.preferences.isTextInteractionEnabled = false
        } else {
            let selectionScript = WKUserScript(source: """
                document.body.style.webkitTouchCallout='none';
                document.body.style.webkitUserSelect='none';
            """, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
            webView.configuration.userContentController.addUserScript(selectionScript)
        }
    }

    func updateButtons(isPositionLocked: Bool = true) {
        guard isPositionLocked != currentIsPositionLocked else { return }

        currentIsPositionLocked = isPositionLocked
        updateMapCenterButton()
        updateNavigationButton()
    }
}

extension StoreMapView {
    func toggleLoadingView(_ shouldShow: Bool) {}

    func zoom(to rect: CGRect, isAnimated: Bool = true) {
        webView.scrollView.zoom(to: rect, animated: isAnimated)
        Log.debug("zoom webView with rect: \(rect)")
    }

    func zoomOut(with zoomScale: CGFloat?, _ completion: @escaping (() -> Void)) {
        let scale = zoomScale ?? webView.scrollView.minimumZoomScale
        Log.debug("zoom out with zoom scale: \(scale)")
        webView.scrollView.setZoomScale(scale, animated: true)

        // Slight delay to give the webview time to zoom back out properly
        DispatchQueue.main.asyncAfter(deadline: .now() + StoreMapConfig.zoomOutAnimationDelay) {
            completion()
        }
    }

    func zoomOnRegion(with rect: CGRect, zoomAnimationDelay: TimeInterval, completion: StoreMapsCompletion?) {
        Log.debug("Zooming to pins in rect: \(rect).")
        DispatchQueue.main.asyncAfter(deadline: .now() + zoomAnimationDelay) {
            self.zoom(to: rect)
            completion?()
        }
    }

    func setZoomScale(to zoomScale: CGFloat, zoomType: ZoomActionType, _ completion: StoreMapsCompletion?) {
        Log.debug("Update Zoom Scale \(zoomScale)")
        webView.scrollView.setZoomScale(zoomScale, animated: true)
        // Slight delay to give the webview time to zoom back out smoothly
        DispatchQueue.main.asyncAfter(deadline: .now() + StoreMapConfig.zoomOutAnimationDelay) {
            completion?()
        }
    }

    func handleNavigationInterruption(for index: Int, status: NavigationStatus?) {
        if index != 0, status == .interrupted {
            isNavigationButtonClicked = false
            updateNavigationButton()
        }
    }

    func refreshNavigationButtonState(_ isVisible: Bool?) {
        if let isVisible, isVisible != lastNavigationButtonVisibility {
            lastNavigationButtonVisibility = isVisible
            updateNavigationButton()
            Log.debug("Navigation button updated with flag: \(isVisible)")
        }
    }

    func previewSetUp(isStaticPathVisible: Bool) {
        buttonStackView.isHidden = isStaticPathVisible
        if options.zoomControlEnabled {
            zoomControlStackView.isHidden = isStaticPathVisible
        }

        if let isPositionLocked = currentIsPositionLocked, !isPositionLocked {
            isLocationStatusVisible = !isStaticPathVisible
        }
    }
}

private extension StoreMapView {
    func resetCenterButtonAndStatus() {
        isCenterButtonClicked = false
        isLocationStatusVisible = false
        updateMapCenterButton()
    }

    func updateMapCenterButton() {
        guard let currentIsPositionLocked, currentIsPositionLocked, options.dynamicMapEnabled else {
            mapCenterButton.isHidden = true
            return
        }

        let iconColor = isCenterButtonClicked ? MapButtonColor.blue : MapButtonColor.black
        DispatchQueue.dispatchToMainIfNeeded {
            self.mapCenterButton.isHidden = false
            self.applyIconButtonStyle(
                self.mapCenterButton,
                image: Asset.Image.mapCenter.image,
                iconColor: iconColor,
                backgroundColor: .white
            )
        }
    }

    func updateNavigationButton() {
        guard
            options.navigationConfig.enabled ?? false,
            !options.navigationConfig.isAutomaticNavigation,
            let canShowNavButton = webViewLoaderViewModel?.canDisplayNavigationButton(),
            canShowNavButton
        else {
            navigationButton.isHidden = true
            return
        }

        guard let isPositionLocked = currentIsPositionLocked, isPositionLocked else {
            navigationButton.isHidden = !isNavigationButtonClicked
            return
        }

        DispatchQueue.dispatchToMainIfNeeded {
            self.navigationButton.isHidden = false
            let iconColor = self.isNavigationButtonClicked ? MapButtonColor.black : UIColor.white
            let backgroundColor = self.isNavigationButtonClicked ? UIColor.white : MapButtonColor.blue
            let image = self.isNavigationButtonClicked ? Asset.Image.routePreviewStop.image : Asset.Image.routePreviewStart.image
            self.applyIconButtonStyle(
                self.navigationButton,
                image: image,
                iconColor: iconColor,
                backgroundColor: backgroundColor
            )
            self.navigationButton.accessibilityIdentifier = self.isNavigationButtonClicked ? "routePreviewStop" : "routePreviewStart"
        }
    }

    private func applyIconButtonStyle(
        _ button: LivingDesign.LDIconButton,
        image: UIImage,
        iconColor: UIColor,
        backgroundColor: UIColor
    ) {
        let highlightedBackground = backgroundColor.withAlphaComponent(0.95)
        let disabledBackground = backgroundColor.withAlphaComponent(0.5)
        let highlightedIconColor = iconColor
        let disabledIconColor = iconColor.withAlphaComponent(0.5)

        let normalColors = LivingDesign.LDIconButton.Appearance.ButtonColors(
            iconColor: iconColor,
            backgroundColor: backgroundColor
        )
        let highlightedColors = LivingDesign.LDIconButton.Appearance.ButtonColors(
            iconColor: highlightedIconColor,
            backgroundColor: highlightedBackground
        )
        let disabledColors = LivingDesign.LDIconButton.Appearance.ButtonColors(
            iconColor: disabledIconColor,
            backgroundColor: disabledBackground
        )

        let variant = LivingDesign.LDIconButton.Appearance.ButtonVariant(
            normal: normalColors,
            highlighted: highlightedColors,
            disabled: disabledColors
        )

        button.appearance = LivingDesign.LDIconButton.Appearance(normal: variant, white: variant)
        button.dataModel = LivingDesign.LDIconButton.Model(
            size: .large,
            image: image,
            color: .default,
            shape: .round
        )
        applyFloatingShadow(to: button)
    }

    private func applyFloatingShadow(to button: UIView) {
        button.layer.shadowColor = UIColor.black.cgColor
        button.layer.shadowOpacity = 0.3
        button.layer.shadowOffset = CGSize(width: 0, height: 2)
        button.layer.shadowRadius = 4
        button.layer.masksToBounds = false
    }

    func getZoomButtonModel(for actionType: ButtonModel.ActionType) -> ButtonModel {
        let image = actionType == .zoomIn ?
        Asset.Image.zoomIn.image : Asset.Image.zoomOut.image

        return ButtonModel(
            type: actionType,
            backgroundColor: .white,
            highlightedBackgroundColor: .gray,
            image: image
        )
    }

    func createZoomButton(with model: ButtonModel) -> CustomButton {
        let zoomButton = CustomButton(with: model) { [weak self] actionType in
            Log.debug("Zoom Button Tapped with actionType \(actionType)")
            self?.resetCenterButtonAndStatus()
            self?.webViewLoaderViewModel?.onStoreMapZoomChange(
                zoomType: actionType == .zoomIn ? .zoomIn : .zoomOut, nil
            )

            _ = self?.zoomControlStackView.arrangedSubviews.map { ContainerView in
                guard  let currentButton = ContainerView as? CustomButton else { return }
                guard  currentButton.type == actionType else {
                    currentButton.backgroundColor = UIColor.clear
                    return
                }
                currentButton.backgroundColor =  UIColor(red: 0.89, green: 0.894, blue: 0.898, alpha: 1)

                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    currentButton.backgroundColor = UIColor.clear
                }
            }
        }
        zoomControlStackView.addArrangedSubview(zoomButton)
        return zoomButton
    }

    func createFloorButton(with model: ButtonModel) -> CustomButton {
        let floorButton = CustomButton(with: model) { [weak self] actionType in
            Log.debug("Floor Button Tapped with actionType \(actionType)")
            self?.floorOneButton?.isSelected = actionType == .floorOne
            self?.floorTwoButton?.isSelected = actionType == .floorTwo
            self?.webViewLoaderViewModel?.onStoreMapFloorChange(
                levelType: actionType == .floorOne ? .floorOne : .floorTwo, nil
            )
            self?.setFloorSelectionAnalytics(floorValue: actionType == .floorOne ? "1" : "2")
        }
        floorControlStackView.addArrangedSubview(floorButton)
        return floorButton
    }

    func getFloorButtonModel(for actionType: ButtonModel.ActionType) -> ButtonModel {
        let image = actionType == .floorOne ?
        Asset.Image.floorOneSelected.image : Asset.Image.floorTwoSelected.image
        let highlightedImage = actionType == .floorOne ?
        Asset.Image.floorOneSelected.image :
        Asset.Image.floorTwoSelected.image
        let disabledImage = actionType == .floorOne ?
        Asset.Image.floorOneUnselected.image :
        Asset.Image.floorTwoUnselected.image

        return ButtonModel(
            type: actionType,
            backgroundColor: .clear,
            highlightedBackgroundColor: .clear,
            image: disabledImage,
            highlightedImage: highlightedImage,
            disabledImage: disabledImage,
            selectedImage: image
        )
    }

    @objc func mapCenterButtonTapped() {
        Log.debug("Map Center Button Tapped")
        isCenterButtonClicked.toggle()
        setMapInteractionAnalytics()
        updateMapCenterButton()
    }

    @objc func navigationButtonTapped() {
        Log.debug("Navigation button tapped")
        if let isNavigationActive = webViewLoaderViewModel?.setNavigation(enabled: &isNavigationButtonClicked),
            isNavigationActive {
            updateNavigationButton()
        } else if options.mapUiConfig.snackBarEnabled == true {
            showSnackbar(message: LocalizedKey.selectPinBeforeRoute.localized)
        }
    }

    private func showSnackbar(message: String, duration: TimeInterval = 3.5) {
           snackbar?.removeFromSuperview()
           let dataModel = LivingDesign.LDSnackbar.Model(
            message: message, actionButtonTitle: nil,
            duration: duration,
            hidesAfterPerformingAction: false,
            needsAccessibilityAnnouncement: true
           )
           let snackbar = LivingDesign.LDSnackbar(dataModel: dataModel)
           snackbar.elevation = nil
           snackbar.layer.masksToBounds = true
           snackbar.onDismiss = { [weak self, weak snackbar] in
               guard let self, self.snackbar === snackbar else { return }
               self.snackbar = nil
           }
           self.snackbar = snackbar
           snackbar.showSnackbar(in: self) { snackbar in
               [
                   snackbar.leadingAnchor.constraint(
                    equalTo: self.safeAreaLayoutGuide.leadingAnchor,
                    constant: LDSpacing.space16
                   ),
                   snackbar.trailingAnchor.constraint(
                    equalTo: self.safeAreaLayoutGuide.trailingAnchor,
                    constant: -LDSpacing.space16
                   ),
                   snackbar.bottomAnchor.constraint(
                    equalTo: self.safeAreaLayoutGuide.bottomAnchor,
                    constant: -LDSpacing.space16
                   )
               ]
           }
       }
    
    func handleError(_ error: StoreMapError) {
        webViewLoaderViewModel?.handleError()
        var errorString = "MapLoad failed"
        switch error {
        case .invalidStatusCode(let statusCode):
            setMapState(.error)
            errorString = "\(errorString) with \(statusCode)"
        case .failedToLoadContent(let error):
            setMapState(.error)
            errorString = "\(errorString) \(error.localizedDescription)"
        case .invalidResponse:
            setMapState(.error)
            errorString = "\(errorString) with invalid HTTPURLResponse or empty response"
        case .mapLoadTimedOut:
            setMapState(.error)
            errorString = "\(errorString): operation time out."
        case .noInternetConnection(let error):
            setMapState(.warning)
            errorString = "\(errorString) \(error.localizedDescription)"
        }

        Log.error(errorString)
    }

    func setupLocationStatusConstraints(constraints: inout [NSLayoutConstraint]) {
        guard options.mapUiConfig.bannerEnabled else { return }

        constraints += [
            locationStatusContainer.topAnchor.constraint(
                equalTo: safeAreaLayoutGuide.topAnchor, constant: LDSpacing.space8),
            locationStatusContainer.leadingAnchor.constraint(
                greaterThanOrEqualTo: safeAreaLayoutGuide.leadingAnchor, constant: 60),
            locationStatusContainer.trailingAnchor.constraint(
                lessThanOrEqualTo: safeAreaLayoutGuide.trailingAnchor, constant: -60),
            locationStatusContainer.centerXAnchor.constraint(equalTo: centerXAnchor)
        ]

        NSLayoutConstraint.activate([
            locationActivityIndicator.widthAnchor.constraint(equalToConstant: LDSpacing.space24),
            locationActivityIndicator.heightAnchor.constraint(equalToConstant: LDSpacing.space24)
        ])

        locationStatusContainer.setContentHuggingPriority(.required, for: .horizontal)
        locationStatusContainer.setContentCompressionResistancePriority(.required, for: .horizontal)
        locationStatusContainer.setContentHuggingPriority(.required, for: .vertical)
        locationStatusContainer.setContentCompressionResistancePriority(.required, for: .vertical)
    }
}

extension StoreMapView: UIScrollViewDelegate {
    func scrollViewDidEndZooming(_ scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat) {
        // For Holiday release, StoreMaps would be loading Level 3 map
        // And there wont be requests to change the map levels
        Log.debug("scrollViewDidEndZooming with scale: \(scale) and with content size: \(scrollView.contentSize)")
        webViewLoaderViewModel?.updateZoomLevel(with: scale)
    }

    func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
        Log.debug("scrollViewWillBeginDragging")

        // Remove the blue dot focus if there is any interaction
        // with the map, such as dragging or pinching the web view.
        self.resetCenterButtonAndStatus()
    }
}

extension StoreMapView: WKNavigationDelegate {
    func webView(_ webView: WKWebView,
                 decidePolicyFor navigationResponse: WKNavigationResponse,
                 decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
        let policy: WKNavigationResponsePolicy

        guard let response = navigationResponse.response as? HTTPURLResponse else {
            policy = .cancel
            handleError(.invalidResponse)
            decisionHandler(policy)
            return
        }

        if response.statusCode < 200 || response.statusCode >= 300 {
            policy = .cancel
            handleError(.invalidStatusCode(response.statusCode))
        } else {
            policy = .allow
        }

        decisionHandler(policy)
    }

    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
        Analytics.telemetry(payload: TelemetryAnalytics(
            isError: true,
            event: DisplayMap.DISPLAY_MAP_ERROR_INVALID_CONTAINER.rawValue
        ))
        guard let error = error as NSError?, error.domain == NSURLErrorDomain else {
            handleError(.failedToLoadContent(error))
            return
        }

        switch error.code {
        case NSURLErrorNotConnectedToInternet:
            handleError(.noInternetConnection(error))
        case NSURLErrorTimedOut:
            handleError(.mapLoadTimedOut)
        default:
            handleError(.failedToLoadContent(error))
        }
    }

    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        isWebViewLoaded = true
        webViewLoaderViewModel?.didLoadWebView()
        disableTextSelection()
        setMapState(.loading(false))
        Analytics.telemetry(payload: TelemetryAnalytics(
            event: DisplayMap.DISPLAY_MAP_WEB_VIEW_LOADED.rawValue
        ))
    }
}
