import SwiftUI
import LivingDesign

final class MapContainerViewController: UIViewController {
    let mapRoot: LDRootViewController
    #if DEBUG
    private var keyboardObserverTokens: [NSObjectProtocol] = []
    private var lastLayoutSnapshot: String = ""
    #endif

    init(mapRoot: LDRootViewController) {
        self.mapRoot = mapRoot
        super.init(nibName: nil, bundle: nil)
    }
    required init?(coder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    override func viewDidLoad() {
        super.viewDidLoad()
        #if DEBUG
        registerKeyboardObservers()
        #endif
    }

    deinit {
        #if DEBUG
        keyboardObserverTokens.forEach {
            NotificationCenter.default.removeObserver($0)
        }
        #endif
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        rehostIfNeeded(reason: "viewWillAppear")
    }

    func rehostIfNeeded(reason: String = "unspecified") {
        #if DEBUG
        debugLog("rehostIfNeeded reason=\(reason)")
        #endif
        let child = mapRoot

        if let parent = child.parent, parent !== self {
            child.willMove(toParent: nil)
            child.view.removeFromSuperview()
            child.removeFromParent()
        }

        if child.parent !== self {
            addChild(child)
            child.didMove(toParent: self)
        }

        if child.view.superview !== view {
            let v = child.view!
            v.translatesAutoresizingMaskIntoConstraints = false
            view.addSubview(v)
            NSLayoutConstraint.activate([
                v.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
                v.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
                v.topAnchor.constraint(equalTo: view.topAnchor), 
                v.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor)
            ])
        }

        view.setNeedsLayout()
        view.layoutIfNeeded()
        #if DEBUG
        logLayout(source: "rehostIfNeeded(\(reason))")
        #endif
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        #if DEBUG
        logLayout(source: "viewDidLayoutSubviews")
        #endif
    }

    #if DEBUG
    private func registerKeyboardObservers() {
        let center = NotificationCenter.default
        let queue = OperationQueue.main

        let willChange = center.addObserver(forName: UIResponder.keyboardWillChangeFrameNotification, object: nil, queue: queue) { [weak self] notification in
            self?.handleKeyboardNotification(notification, label: "keyboardWillChangeFrame")
        }
        let didShow = center.addObserver(forName: UIResponder.keyboardDidShowNotification, object: nil, queue: queue) { [weak self] notification in
            self?.handleKeyboardNotification(notification, label: "keyboardDidShow")
        }
        let didHide = center.addObserver(forName: UIResponder.keyboardDidHideNotification, object: nil, queue: queue) { [weak self] notification in
            self?.handleKeyboardNotification(notification, label: "keyboardDidHide")
        }

        keyboardObserverTokens = [willChange, didShow, didHide]
    }

    private func handleKeyboardNotification(_ notification: Notification, label: String) {
        guard let userInfo = notification.userInfo else {
            debugLog("\(label): no userInfo")
            return
        }

        let frameEnd = (userInfo[UIResponder.keyboardFrameEndUserInfoKey] as? NSValue)?.cgRectValue ?? .null
        let frameBegin = (userInfo[UIResponder.keyboardFrameBeginUserInfoKey] as? NSValue)?.cgRectValue ?? .null
        let duration = userInfo[UIResponder.keyboardAnimationDurationUserInfoKey] as? Double ?? -1
        let curveRaw = userInfo[UIResponder.keyboardAnimationCurveUserInfoKey] as? UInt ?? 0

        debugLog("\(label): begin=\(rectString(frameBegin)) end=\(rectString(frameEnd)) duration=\(duration) curve=\(curveRaw)")
    }

    private func logLayout(source: String) {
        let boundsString = rectString(view.bounds)
        let safeInsets = view.safeAreaInsets
        let childFrame = mapRoot.view?.frame ?? .null
        let superviewMatch = mapRoot.view?.superview === view
        let snapshot = "bounds=\(boundsString) safeInsets=\(insetsString(safeInsets)) childFrame=\(rectString(childFrame)) superviewMatch=\(superviewMatch) subviews=\(view.subviews.count)"

        if snapshot != lastLayoutSnapshot {
            debugLog("layout[\(source)]: \(snapshot)")
            lastLayoutSnapshot = snapshot
        } else {
            debugLog("layout[\(source)]: unchanged")
        }
    }

    private func debugLog(_ text: String) {
        print("[MapContainerViewController] \(text)")
    }

    private func rectString(_ rect: CGRect) -> String {
        if rect.isNull {
            return "null"
        }
        return "(\(rect.origin.x.rounded(toPlaces: 2)),\(rect.origin.y.rounded(toPlaces: 2)),\(rect.size.width.rounded(toPlaces: 2)),\(rect.size.height.rounded(toPlaces: 2)))"
    }

    private func insetsString(_ insets: UIEdgeInsets) -> String {
        "top:\(insets.top.rounded(toPlaces: 2)) left:\(insets.left.rounded(toPlaces: 2)) bottom:\(insets.bottom.rounded(toPlaces: 2)) right:\(insets.right.rounded(toPlaces: 2))"
    }
    #endif
}

struct MapRootHost: UIViewControllerRepresentable {
    let viewController: LDRootViewController

    func makeUIViewController(context: Context) -> MapContainerViewController {
        MapContainerViewController(mapRoot: viewController)
    }

    func updateUIViewController(_ uiViewController: MapContainerViewController, context: Context) {
        uiViewController.rehostIfNeeded(reason: "updateUIViewController")
    }
}

struct KeyboardIgnoringMapHost: View {
    let viewController: LDRootViewController

    var body: some View {
        GeometryReader { proxy in
            MapRootHost(viewController: viewController)
                .background(Color(.systemBackground))
                .clipShape(RoundedRectangle(cornerRadius: 8))
                .frame(width: proxy.size.width, height: proxy.size.height)
        }
        .ignoresSafeArea(.keyboard, edges: .bottom)
    }
}

#if DEBUG
private extension CGFloat {
    func rounded(toPlaces places: Int) -> CGFloat {
        guard places >= 0 else { return self }
        let divisor = CGFloat(pow(10.0, Double(places)))
        return (self * divisor).rounded() / divisor
    }
}
#endif
