
import Foundation
import Combine

class ScanResultViewModel: ObservableObject {
    // Use the NEW API model directly - no old model involved
    @Published var modHealthResponse: ModHealthResponseData?
    @Published var isLoading = true
    @Published var error: Error?
    
    private let pollingService: ModHealthPollingServiceType
    private var cancellables = Set<AnyCancellable>()
    
    init(pollingService: ModHealthPollingServiceType = ModHealthPollingService(keychainService: KeychainService.standard)) {
        self.pollingService = pollingService
        // NO MOCK DATA - we only use real API now
    }
    
    /// Call this method with the WUID received from the upload API
    func startPolling(with wuId: String) {
        isLoading = true
        error = nil
        
        Log.info("Starting mod-health polling for WUID: \(wuId)")
        
        pollingService.pollTaskStatus(wuId: wuId)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        Log.error("Mod-health polling failed: \(error)")
                        self?.error = error
                        self?.isLoading = false
                    }
                },
                receiveValue: { [weak self] apiData in
                    if let apiData = apiData {
                        // NO MAPPING - use API data directly
                        self?.modHealthResponse = apiData
                        self?.isLoading = false
                    } else {
                        Log.warning("No data received from mod-health API")
                        self?.error = NSError(domain: "ModHealth", code: 404, userInfo: [NSLocalizedDescriptionKey: "No data received from API"])
                        self?.isLoading = false
                    }
                }
            )
            .store(in: &cancellables)
        
        // MARK: - Future Implementation (commented out for now)
        /*
        // For continuous polling every 30 seconds:
        pollingService.startContinuousPolling(wuId: wuId, interval: 30.0)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    if case .failure(let error) = completion {
                        Log.error("Continuous polling failed: \(error)")
                        self?.error = error
                    }
                },
                receiveValue: { [weak self] apiData in
                    if let apiData = apiData {
                        self?.modHealthResponse = apiData
                        self?.isLoading = false
                    }
                }
            )
            .store(in: &cancellables)
        */
    }
}
