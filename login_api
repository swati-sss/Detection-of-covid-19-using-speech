import Combine
import CoreData
import Foundation

import IPSFramework

protocol CompassViewModelType {
    var rootViewController: UIViewController? { get set }

    func getAccessToken(authParameter: AuthParameter) -> AnyPublisher<AccessTokenResponse?, Error>
    func toggleMockUser(_ option: Bool)
    func updateStoreConfiguration(_ storeConfig: StoreConfig?)
    func getAisle(id: String)
    func isMapViewReady() -> AnyPublisher<Bool, Never>
    func displayMap()
    func clearMap(mapConfig: MapConfig)
    func updateEvent(compassEvent: CompassEvent)
    func updateEventList(namespace: String, eventType: String, eventValue: String, metaData: HashMap?)
    func displayPin(uuidList: [String], idType: PinDropMethod, config: DisplayPinConfig?)
    func displayPin(pins: [CompassPin]?, config: DisplayPinConfig?)
    func displayStaticPath(pins: [CompassPin], startFromNearbyEntrance: Bool, disableZoomGestures: Bool)
    func startPositionSession()
    func stopPositioning()
    func resetPositionStatusEvent()
    func killSwitch()
    func removeUserPositionIndicator()
    func getUserDistance(pins: [AislePin], completion: UserDistanceCompleteHandler?)
}

final class CompassViewModel: CompassViewModelType {
    internal var mapHostViewModel: MapHostViewModelType?
    internal var isPositioningEnabled: Bool = false
    private var includeLocationInHeatbeat: Bool = false
    private var includeUserInHeatbeat: Bool = false
    private var positioningSessioinTimeout: Int = 2
    internal var positionSessionTimer: Timer?
    internal var positionRefreshTime: Double = 1.0
    internal var sessionRefreshTime: Int = SessionTime.positionRefreshTime
    internal var assetService: AssetService
    let serviceLocator: ServiceLocatorType
    private var cancellable: Set<AnyCancellable> = []
    private var shouldClearBlueDot: Bool = false
    private let defaultsStore: UserDefaultsStore

    weak var rootViewController: UIViewController?

    init(serviceLocator: ServiceLocatorType, defaultsStore: UserDefaultsStore = UserDefaultsStore()) {
        self.serviceLocator = serviceLocator
        self.assetService = serviceLocator.getAssetService()
        self.defaultsStore = defaultsStore
        Analytics.logDefault = serviceLocator.getLogDefaultImpl()
        bindAppLifecycleObservation()
    }

    /// Initialize the CompassViewModel class.
    /// This is use to assign accessTokenService and configurationService.

    /// This is used to retrieve access token based on clientId and consumerId.
    /// Will also store access token data in core data model .
    func getAccessToken(authParameter: AuthParameter) -> AnyPublisher<AccessTokenResponse?, Error> {
        guard !authParameter.authToken.isEmptyOrWhitespace() else {
            self.logAndHandleEmptyAuthParameter()
            return Fail(error: CompassError(.authToken)).eraseToAnyPublisher()
        }
        return self.handleTokenType(for: authParameter).eraseToAnyPublisher()
    }

    func toggleMockUser(_ option: Bool) {
        Log.info("Set up Mock User: \(option)")
        if option {
            IPSPositioning.testLockThreshold = 0
        }
    }

    func updateStoreConfiguration(_ storeConfig: StoreConfig?) {
        #if DEBUG
        if let assetService = serviceLocator.getAssetService() as? AssetServiceImpl {
            assetService.lastStoreConfig = storeConfig
        }
        #endif
        positionRefreshTime = storeConfig?.positioningSessionTimeout ?? 1
        sessionRefreshTime = storeConfig?.sessionRefreshTime ?? sessionRefreshTime
        setStore(using: storeConfig)
        setSupportedEventList(using: storeConfig)
        setMapType(using: storeConfig)
        setupLogIntervalsData(storeConfig: storeConfig)
        defaultsStore.saveSessionId()
    }

    func getAisle(id: String) {
        mapHostViewModel?.getAisle(id: id)
    }

    func isMapViewReady() -> AnyPublisher<Bool, Never> {
        serviceLocator.getMapFocusManager().isMapViewPresent.eraseToAnyPublisher()
    }

    func displayMap() {
        Log.debug("API Called: displayMap")
        Analytics.telemetry(payload: TelemetryAnalytics(event: DisplayMap.DISPLAY_MAP_REQUESTED.rawValue))
        startPositionSession()
        mapHostViewModel?.displayMap()
    }

    func clearMap(mapConfig: MapConfig) {
        Log.debug("API Called: clearMap with config: \(mapConfig)")
        mapHostViewModel?.clearMap(mapConfig: mapConfig)
    }

    func updateEvent(compassEvent: CompassEvent) {
        Log.debug("API Called: updateEvent for event: \(compassEvent)")

        startPositionSession()

        guard let position = serviceLocator.getIndoorPositioningService().lastLockedPosition else {
            Log.info("The value of lastLockedPosition is nil")
            emitUpdateEventError()
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: UpdateEvent.UPDATE_EVENT_ERROR_NOT_LOCKED.rawValue
            ))
            return
        }

        guard let converter = serviceLocator.getIndoorPositioningService().floorCoordinatesConverter else {
            Log.info("The value of floorCoordinatesConverter is nil")
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: UpdateEvent.UPDATE_EVENT_ERROR_NOT_LOCKED.rawValue
            ))
            emitUpdateEventError()
            return
        }

        Task { [weak self] in
            guard let self else { return }
            let bootstrapStatus = await serviceLocator.getEventService()
                .cacheAndBootstrapAsset(
                    compassEvent, position: position.convertToCompass(using: converter).asCGPoint()
                )
            if bootstrapStatus == .notBootstrapped {
                self.emitUpdateEventError()
                Analytics.telemetry(payload: TelemetryAnalytics(
                    isError: true,
                    event: UpdateEvent.UPDATE_EVENT_ERROR_QUADTREE_CALC.rawValue
                ))
            }
        }
    }

    func updateEventList(namespace: String, eventType: String, eventValue: String, metaData: HashMap?) {
        guard isPositioningEnabled else {
            Log.info("Blue dot is disabled")
            return
        }

        startPositionSession()
        let supportedEventList = assetService.supportedEventList.components(
            separatedBy: "},"
        )
        let eventKey = "\(namespace)/\(eventType)"
        let isSupportedEvent = supportedEventList.filter {
            $0.lowercased().contains(eventKey.lowercased()) &&
            ($0.lowercased().contains("\"enabled\": true") || $0.lowercased().contains("\"enabled\":true"))
        }

        guard !isSupportedEvent.isEmpty else {
            Log.info("The event list is not supported.")
            emitUpdateEventListError()
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: UpdateEvent.UPDATE_EVENT_ERROR_INVALID_INPUT.rawValue
            ))
            return
        }

        let position = serviceLocator.getIndoorPositioningService().lastLockedPosition
        let converter = serviceLocator.getIndoorPositioningService().floorCoordinatesConverter

        let compassPosition: CGPoint?
        if let converter {
            compassPosition = position?.convertToCompass(using: converter).asCGPoint()
        } else {
            compassPosition = nil
        }

        let eventAnalytics: EventAnalytics.EventLocation?
        if let compassPosition {
            eventAnalytics = EventAnalytics.EventLocation(
                roc: EventAnalytics.EventLocationRoc(x: compassPosition.x, y: compassPosition.y)
            )
        } else {
            eventAnalytics = nil
        }

        let event = EventAnalytics.Event(
            id: RequestIdentifier.id1.rawValue,
            type: eventType,
            value: eventValue,
            properties: metaData?.toCodableValueDictionary()
        )

        Log.info("""
                 [COVERAGE] updateEventList block executed for namespace: \(namespace),
                 eventType: \(eventType), eventValue: \(eventValue)
            """)
        let payload = EventAnalytics(namespace: namespace,
                                     location: eventAnalytics,
                                     event: event,
                                     isPositionLocked: position?.isLocked ?? false)

        Analytics.updateEvent(payload: payload)
        Log.info("Update Event List: \(payload)")
        self.serviceLocator.getStatusService().emitUpdateEventList(description: "Compass UpdateEventList success")
    }

    func resetPositionStatusEvent() {
        self.serviceLocator.getStatusService().resetCompassPositionType()

        guard !isPositioningEnabled else { return }
        self.serviceLocator.getStatusService().emitPositionStatusEvent(
            calibrationProgress: 0,
            isCalibrationGestureNeeded: false,
            positioningProgress: 0,
            isPositionLocked: true
        )
    }

    func displayPin(uuidList: [String], idType: PinDropMethod, config: DisplayPinConfig?) {
        Log.debug("displayPin called: \(uuidList), idType:\(idType.rawValue), config: \(String(describing: config))")
        startPositionSession()
        mapHostViewModel?.displayPin(uuidList: uuidList, idType: idType, config: config)
    }

    func displayPin(pins: [CompassPin]?, config: DisplayPinConfig?) {
        startPositionSession()
        mapHostViewModel?.displayPin(pins: pins, config: config)
    }

    func displayStaticPath(pins: [CompassPin], startFromNearbyEntrance: Bool, disableZoomGestures: Bool) {
        Log.debug(
            """
            API Called: displayStaticPath for: \(pins),
            startFromNearbyEntrance:\(startFromNearbyEntrance),
            disableZoomGestures: \(disableZoomGestures)
            """
        )
        startPositionSession()
        mapHostViewModel?.displayStaticPath(pins: pins,
                                            startFromNearbyEntrance: startFromNearbyEntrance,
                                            disableZoomGestures: disableZoomGestures)
    }

    // If multiple getUserDistance calls are made in quick succession (example: by different UI actions or async flows)
    // the requestId helps us match each response to its original request.
    func getUserDistance(pins: [AislePin], completion: UserDistanceCompleteHandler?) {
        Log.debug("API Called: getUserDistance for pins: \(pins)")
        startPositionSession()
        mapHostViewModel?.getUserDistance(pins: pins, completion: completion)
    }

    func killSwitch() {
        stopPositioning()
        serviceLocator.getUserPositionManager().logout()
        cancellable.removeAll()
    }

    func removeUserPositionIndicator() {
        guard let mapHostViewModel = mapHostViewModel else {
            Log.warning("Cannot remove user position indicator: mapHostViewModel is nil")
            return
        }
        mapHostViewModel.removeUserPositionIndicator()
    }

    deinit {
        positionSessionTimer?.invalidate()
        positionSessionTimer = nil
        Log.info("Released CompassViewModel")
    }
}
