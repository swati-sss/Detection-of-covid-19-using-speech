import Combine
import IPSFramework
import LivingDesign
import PluginAPIs
import SwiftUI
import UIKit
import UserNotifications
import compass_sdk_ios

final class HomeViewModel: ObservableObject {
    @Published var storeIDText = String(Environment.initialStore)
    @Published var customMapStoreIDText = ""
    @Published var consoleText = ""
    @Published private var consoleScrollToken = 0
    @Published var calibrationProgress = 0.0
    @Published var positioningProgress = 0.0
    @Published var isPositionLocked = false

    @Published var shouldZoomOnPins = true
    @Published var resetZoom = false
    @Published var isConsoleHidden = true

    private let compassAPI = CompassPluginAPI()
    private var compassViewController: UIViewController?
    var currentStore: Int?
    var cancellables = Set<AnyCancellable>()
    let mapRootViewController = LDRootViewController()

    var pinDropEventEmitterHandler: ((CompassEventEmitter) -> Void)?
    var pinClickedEventEmitterHandler: ((CompassEventEmitter) -> Void)?
    var aislePinDropEventEmitterHandler: ((CompassEventEmitter) -> Void)?
    var bootstrapEventEmitterHandler: ((CompassEventEmitter) -> Void)?
    var updateEventListEmitterHandler: ((CompassEventEmitter) -> Void)?
    var errorEventEmitterHandler: ((CompassEventEmitter) -> Void)?

    typealias AisleTuple = (zone: String, aisle: String, section: String, selected: Bool)

    private var currentGeoFenceState: String? = "undefined"

    var enableManualPinDrop = true
    var displayPinConfig: compass_sdk_ios.DisplayPinConfig {
        compass_sdk_ios.DisplayPinConfig(
            enableManualPinDrop: enableManualPinDrop,
            resetZoom: resetZoom,
            shouldZoomOnPins: shouldZoomOnPins
        )
    }

    private let localMapDefaultsKey = "CompassLocalMapHTMLPath"
    @Published private(set) var localMapURL: URL?

    init() {
//        loadLocalMapOverride()
    }

    private static let timestampFormatter: DateFormatter = {
        let df = DateFormatter()
        df.dateFormat = "hh:mm:ss.SSSS"
        return df
    }()

    func consoleLog(_ text: String) {
        let ts = Self.timestampFormatter.string(from: Date())
        let chunk = "\n\n\(ts)\n\(text)"
        DispatchQueue.main.async {
            self.consoleText += chunk
            self.consoleScrollToken &+= 1
        }
    }

    var scrollToken: Int { consoleScrollToken }

    func reset() {
        cancellables.removeAll()
    }

    func sendGeoFenceEnteredNotification() {
        NotificationManager.shared.post(
            title: "Geofence",
            body: "You entered the store geofence",
            id: "geofence-entered"
        )
    }

    func sendGeoFenceExitedNotification() {
        NotificationManager.shared.post(title: "Geofence", body: "You exited the store geofence", id: "geofence-exited")
    }

    func sendPositionDropNotification() {
        NotificationManager.shared.post(
            title: "Position Lost",
            body: "Indoor positioning has lost track of your location",
            id: "position-dropped"
        )
    }

    func copyConsoleTextToClipboard() {
        UIPasteboard.general.string = consoleText
    }

    func clearConsole() {
        consoleText = ""
    }

    func toggleConsoleVisibility() {
        isConsoleHidden.toggle()
    }

    func clearMap() {
        compassAPI.clearMap(configuration: compass_sdk_ios.MapConfig(resetZoom: resetZoom).hashMap)
    }

    func stopPositioning() {
        compassAPI.stopPositioning()
    }

    func getLocation(assetId: String) {
        compassAPI.getAisle(id: assetId)
    }

    func killSwitch() {
        removeCompassAndDestroyRoot()
    }

    func removeCompassAndDestroyRoot() {
        compassAPI.killSwitch()

        if let compassViewController {
            compassViewController.willMove(toParent: nil)
            compassViewController.view.removeFromSuperview()
            compassViewController.removeFromParent()
        }

        mapRootViewController.view.subviews.forEach { $0.removeFromSuperview() }

        compassViewController = nil
    }

    private func normalizeStoreInput() {
        let trimmedStore = storeIDText.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedStore.isEmpty || Int(trimmedStore) == nil {
            storeIDText = String(Environment.initialStore)
        } else if trimmedStore != storeIDText {
            storeIDText = trimmedStore
        }
    }

    private func restartCompassIfNeeded() {
        guard compassViewController != nil else { return }
        removeCompassAndDestroyRoot()
        currentStore = nil
        initialize(false)
    }

    // private func loadLocalMapOverride() {
    //    let defaults = UserDefaults.standard
    //    guard let storedPath = defaults.string(forKey: localMapDefaultsKey) else {
    //        localMapURL = nil
    //        Compass.setLocalMapFileURL(nil)
    //        return
    //    }
    //
    //    let url = URL(fileURLWithPath: storedPath)
    //    if FileManager.default.fileExists(atPath: url.path) {
    //        localMapURL = url
    //        Compass.setLocalMapFileURL(url)
    //    } else {
    //        defaults.removeObject(forKey: localMapDefaultsKey)
    //        localMapURL = nil
    //        Compass.setLocalMapFileURL(nil)
    //    }
    // }

    // func setLocalMapOverride(_ url: URL?) {
    //    if localMapURL == url {
    //        return
    //    }
    //
    //    let defaults = UserDefaults.standard
    //    if let url {
    //        defaults.set(url.path, forKey: localMapDefaultsKey)
    //    } else {
    //        defaults.removeObject(forKey: localMapDefaultsKey)
    //    }
    //
    //    localMapURL = url
    //    Compass.setLocalMapFileURL(url)
    //    compass?.setLocalMapFileURL(url)
    //
    //    if let url {
    //        consoleLog("Local map override loaded: \(url.lastPathComponent)")
    //    } else {
    //        consoleLog("Local map override cleared. Reverting to backend map.")
    //    }
    //
    //    normalizeStoreInput()
    //    restartCompassIfNeeded()
    // }

    var localMapFileName: String? {
        localMapURL?.lastPathComponent
    }

    func applyEnvironmentChangesAndReinitializeIfNeeded() {
        normalizeStoreInput()
        if Environment.mockUser {
            IPSPositioning.testLockThreshold = 0
        } else {
            IPSPositioning.testLockThreshold = 1
        }
        restartCompassIfNeeded()
    }

    func updateEvent() {
        Log.debug("Compass: updateEvent called.")
        compassAPI.state
            .filter { $0 == .initializationComplete }
            .first()
            .sink { [weak self] _ in
                let uuid =
                    self?.storeIDText == DebugData.StoreID.oriient ?
                    DebugData.asset2280List.shuffled() : DebugData.asset3594List.shuffled()

                guard let assetId = uuid.first
                else {
                    Log.debug("Compass: isInitialize is not set.")
                    return
                }

                let compassEvent = PluginAPIs.CompassEvent(
                    eventType: "asset_scan",
                    eventValue: assetId,
                    eventMetadata: [:]
                )
                self?.compassAPI.updateEvent(compassEvent: compassEvent)
            }
            .store(in: &cancellables)

        var isCancelled = false
        var updateStatus = true

        // Observe error and progress update
        bootstrapEventEmitterHandler = { eventEmitter in
            var dict = eventEmitter.toDictionary()
            Log.debug("The value of bootstrapEventEmitterHandler dict is:\(dict)")
            dict["eventType"] = nil

            DispatchQueue.main.async {
                self.consoleLog("BOOTSTRAP EVENT:\n\(dict.toJSONString() ?? "")")
            }

            isCancelled = true

            guard updateStatus else {
                return
            }

            updateStatus = false
            Log.debug("Compass updateEvent success")
        }

        if !isCancelled {
            errorEventEmitterHandler = { errorEventEmitter in
                let dict = errorEventEmitter.toDictionary()
                Log.debug("The value of errorEventEmitterHandler dict is:\(dict)")

                var event = [String: Any]()
                if let code = dict["errorCode"] as? Int {
                    event["code"] = code
                }
                if let errorType = dict["compassErrorType"] as? String {
                    event["errortype"] = errorType
                }
                if let message = dict["errorDescription"] as? String {
                    event["message"] = message
                }

                DispatchQueue.main.async {
                    self.consoleLog("ERROR EVENT:\n\(event.toJSONString() ?? "")")
                }

                Log.debug(" sendEvent errorEventEmitter body: \(event)")
                guard updateStatus else {
                    return
                }

                updateStatus = false
                Log.debug("-1 Compass updateEvent failed")
            }
        }
    }

    func updateEventList() {
        Log.debug("Compass: updateEvent List called.")

        var isCancelled = false
        var updateStatus = true

        updateEventListEmitterHandler = { eventEmitter in
            var dict = eventEmitter.toDictionary()
            Log.debug("The value of updateEventListEmitterHandler dict is:\(dict)")
            dict["eventType"] = nil

            DispatchQueue.main.async {
                self.consoleLog("UPDATE EVENT LIST:\n\(dict.toJSONString() ?? "")")
            }

            isCancelled = true

            guard updateStatus else {
                return
            }

            updateStatus = false
            Log.debug("Compass updateEvent list success")
        }
        if !isCancelled {
            errorEventEmitterHandler = { errorEventEmitter in
                let dict = errorEventEmitter.toDictionary()
                Log.debug("The value of errorEventEmitterHandler dict is:\(dict)")

                var event = [String: Any]()
                if let code = dict["errorCode"] as? Int {
                    event["code"] = code
                }
                if let errorType = dict["compassErrorType"] as? String {
                    event["errortype"] = errorType
                }
                if let message = dict["errorDescription"] as? String {
                    event["message"] = message
                }

                DispatchQueue.main.async {
                    self.consoleLog("ERROR EVENT:\n\(event.toJSONString() ?? "")")
                }

                Log.debug(" sendEvent errorEventEmitter body: \(event)")
                guard updateStatus else {
                    return
                }

                updateStatus = false
                Log.debug("-1 Compass updateEvent failed")
            }
        }

        compassAPI.state
            .filter { $0 == .initializationComplete }
            .first()
            .sink { [weak self] _ in
                let uuid =
                    self?.storeIDText == DebugData.StoreID.oriient ?
                    DebugData.asset2280List.shuffled() : DebugData.asset3594List.shuffled()

                guard let assetId = uuid.first
                else {
                    Log.debug("Compass: isInitialize is not set.")
                    return
                }

                self?.compassAPI.updateEventList(
                    namespace: "MODFLEX",
                    eventType: "SCAN_FEATURE_LOCATION",
                    eventValue: "BK4-12",
                    metaData: [
                        "keyA": "va",
                        "keyB": "vb",
                        "keyC": "vc",
                        "keyD": "vd",
                        "keyE": "ve",
                        "keyF": "vf"
                    ]
                )
            }
            .store(in: &cancellables)
    }

    func initialize(_ disableAutoZoom: Bool) {
        normalizeStoreInput()
        reset()
        currentStore = compassAPI.currentStore

        guard let site = Int(storeIDText) else {
            Log.debug("Compass Initialization failed: invalid store ID")
            return
        }

        guard currentStore != site else {
            compassAPI.resetPositionStatusEvent()
            Log.debug("Already on store \(site), skipping initialization; resetting position status")
            return
        }

        if compassViewController == nil {
            compassViewController = compassAPI.makeCompassViewController()
        }

        // Register this view model as the webview message delegate via the
        // public Compass API so HomeView can provide the delegate to the SDK.
        compassAPI.setWebViewMessageDelegate(self)

        let authParameter = Environment.authParmeter
        let configuration = Environment.getConfiguration(for: site)
        var updateStatus = true

        compassAPI.setEnvironment(Environment.backendEnv)

        cancellables.removeAll()
        consoleText = ""

        compassAPI.initialize(
            authParameter: authParameter,
            configuration: configuration,
            rootViewController: mapRootViewController
        )

        let initSuccessPublisher = compassAPI.state
            .filter { $0 == .initializationComplete }
            .combineLatest(compassAPI.isBlueDotEnabled.compactMap { $0 })

        initSuccessPublisher
            .sink { [weak self] _, isBlueDotEnabled in
                guard let self else { return }
                Log.debug("Compass: isBlueDotEnabled: \(isBlueDotEnabled)")
                self.currentStore = site
                self.consoleLog("Compass Initialization Succeeded")
                Log.debug("Compass: Compass initialization is success")
                guard updateStatus else { return }
                updateStatus = false
                Log.debug("Compass Initialization success")
            }
            .store(in: &cancellables)

        compassAPI.state
            .compactMap { state -> String? in
                if case let .initializationFailed(message) = state {
                    return message
                }
                return nil
            }
            .sink { [weak self] message in
                Log.debug("Compass: Compass Initialization Failed")
                DispatchQueue.main.async {
                    self?.consoleLog("Compass Initialization Failed: \(message)")
                }
                guard updateStatus else { return }
                updateStatus = false
                Log.debug("-1 Compass Initialization failed")
            }
            .store(in: &cancellables)

        let errorEventEmitterCompletionHandler: ([String: Any]) -> Void = { dict in
            var event = [String: Any]()
            if let code = dict["errorCode"] as? Int {
                event["code"] = code
            }
            if let errortype = dict["compassErrorType"] as? String {
                event["errortype"] = errortype
            }
            if let message = dict["errorDescription"] as? String {
                event["message"] = message
            }
            DispatchQueue.main.async {
                self.consoleLog("ERROR EVENT:\n\(event.toJSONString() ?? "")")
            }
            Log.debug("The value of errorEventEmitter dict is:\(event)")
            guard updateStatus else { return }
            updateStatus = false
            Log.debug("-1 Compass Initialization failed")
        }

        waitForEventEmitterCompletionHandlerResponse(with: errorEventEmitterCompletionHandler)
        waitForIsFinishedSettingMapResponse()
    }

    func waitForEventEmitterCompletionHandlerResponse(
        with errorEventEmitterCompletionHandler: @escaping ([String: Any]) -> Void
    ) {
        compassAPI.setEventEmitterHandler { [weak self] eventEmitter in
            guard let self else { return }
            let dict = eventEmitter.toDictionary()
            switch eventEmitter.eventType {
            case .showMapEventEmitter:
                var hashMap = dict
                hashMap["eventType"] = nil
                DispatchQueue.main.async {
                    self.consoleLog("SHOW MAP EVENT:\n\(hashMap.toJSONString() ?? "")")
                }
                Log.debug("The value of mapButtonEventEmitter dict is:\(hashMap)")
            case .mapStatusEventEmitter:
                var hashMap = dict
                hashMap["eventType"] = nil
                DispatchQueue.main.async {
                    self.consoleLog("MAP STATUS EVENT:\n\(hashMap.toJSONString() ?? "")")
                }
                Log.debug("The value of mapStatusEventEmitter dict is:\(hashMap)")
            case .bootstrapEventEmitter:
                self.bootstrapEventEmitterHandler?(eventEmitter)
            case .updateEventListEventEmitter:
                self.updateEventListEmitterHandler?(eventEmitter)
            case .pinListEventEmitter:
                self.pinDropEventEmitterHandler?(eventEmitter)
            case .pinClickedEventEmitter:
                self.pinClickedEventEmitterHandler?(eventEmitter)
            case .aislesPinListEventEmitter:
                self.aislePinDropEventEmitterHandler?(eventEmitter)
            case .errorEventEmitter:
                self.errorEventEmitterHandler?(eventEmitter)
            case .positioningStateEventEmitter:
                DispatchQueue.main.async {
                    let calibration = dict["calibrationProgress"] as? Double
                        ?? (dict["calibrationProgress"] as? Int).map(Double.init)
                        ?? 0.0
                    let positioning = dict["positioningProgress"] as? Double
                        ?? (dict["positioningProgress"] as? Int).map(Double.init)
                        ?? 0.0
                    let isLocked = dict["isPositionLocked"] as? Bool ?? false

                    self.calibrationProgress = calibration / 100.0
                    self.positioningProgress = positioning / 100.0

                    if isLocked, !self.isPositionLocked {
                        self.isPositionLocked = true
                        self.consoleLog("**** POSITION LOCKED ****")
                    }
                    if !isLocked && self.isPositionLocked {
                        self.isPositionLocked = false
                        self.consoleLog("**** POSITION DROPPED ****")
                        self.sendPositionDropNotification()
                    }
                }

            case .positionEventEmitter:
                if let positionType = dict["positionType"] as? String {
                    var event = [String: Any]()
                    event["EventType"] = positionType
                    event["EventCode"] = dict["positionCode"]
                    DispatchQueue.main.async {
                        self.consoleLog("POSITIONING EVENT:\n\(event.toJSONString() ?? "")")
                    }
                    Log.debug("The value of positionEventEmitter dict is:\(event)")
                }

                if let position = dict["positionCode"] as? Int, position == 0 {
                    self.updateEvent()
                }
            case .initErrorEventEmitter:
                errorEventEmitterCompletionHandler(dict)
            case .geofenceStateEventEmitter:
                let newState = dict["state"] as? String
                    ?? dict["geofenceState"] as? String
                    ?? "undefined"
                let previousState = self.currentGeoFenceState ?? "undefined"

                guard previousState != newState else {
                    Log.debug("Geofence state unchanged: \(newState)")
                    return
                }

                switch newState {
                case "inside":
                    if previousState == "outside" || previousState == "undefined" {
                        self.sendGeoFenceEnteredNotification()
                        self.consoleLog("**** ENTERED GEOFENCE from \(previousState) ****")
                    }
                case "outside":
                    if previousState == "inside" || previousState == "undefined" {
                        self.sendGeoFenceExitedNotification()
                        self.consoleLog("**** EXITED GEOFENCE ****")
                    }
                default:
                    self.consoleLog("**** UNKNOWN state: \(newState) ****")
                }
                self.currentGeoFenceState = newState
            default:
                break
            }
        }
    }

    func waitForIsFinishedSettingMapResponse() {
        compassAPI.state
            .filter { $0 == .mapLoaded }
            .sink { [weak self] _ in
                self?.compassAPI.displayMap(
                    workflow: PluginAPIs.CompassWorkflow(id: "sample_app_id", type: "sample_app_flow", value: "sa_val")
                )
            }
            .store(in: &cancellables)
    }

    func evaluateJsExample() {
        guard compassViewController != nil else {
            consoleLog("evaluateJsExample: Compass is not initialized")
            return
        }

        let payload =
            "{\"type\":\"RENDER_PINS_REQUESTED\",\"payload\":{\"pinGroupingEnabled\":true,\"pins\":[{\"aisle\":1,\"selected\":true,\"type\":\"aisle-section\",\"shouldFetchData\":false,\"zone\":\"A\",\"grouped\":true,\"section\":1,\"groupedPins\":[],\"checked\":false}]}}"
        let escaped = payload.replacingOccurrences(of: "'", with: "\\'")
        compassAPI.evaluateJSOnWebView("sendMessage('\(escaped)')")
    }

    func displayAssetPin(id: String) {
        guard !id.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        setAndGetAssetsEventStatus()
        compassAPI.displayPin(uuidList: [id], idType: .assets, config: displayPinConfig.hashMap)
    }

    func displayGenericPin(encodedId: String) {
        guard !encodedId.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else { return }
        setAndGetAssetsEventStatus()
        compassAPI.displayPin(uuidList: [encodedId], idType: .generic, config: nil)
    }

    func displayPinsV2(pins: [AisleTuple], isStaticPathVisible: Bool = false) {
        var updateStatus = true

        aislePinDropEventEmitterHandler = { pinDropEventEmitter in
            var dict = pinDropEventEmitter.toDictionary()
            dict["eventType"] = nil

            Log.debug("The value of aislePinDropEventEmitterHandler dict is:\(dict)")
            if let output = dict.toJSONString() {
                Log.debug("Display Pins Payload for Aisle: \(output)")
                DispatchQueue.main.async {
                    self.consoleLog("PIN DROP V2 EVENT:\n\(output)")
                }
            }

            guard updateStatus else {
                return
            }

            updateStatus = false
            Log.debug("displaypin success")
        }

        pinClickedEventEmitterHandler = { pinClickedEventEmitter in
            var dict = pinClickedEventEmitter.toDictionary()
            dict["eventType"] = nil
            Log.debug("The value of pinClickedEventEmitterHandler dict is:\(dict)")
            if let output = dict.toJSONString() {
                Log.debug("Pin Clicked: \(output)")
                DispatchQueue.main.async {
                    self.consoleLog("PIN CLICKED EVENT:\n\(output)")
                }
            }
        }

        var isZoomOutRequired = true
        let aislePins: [PluginAPIs.CompassAislePin] = pins.map { tuple in
            if !tuple.zone.isEmpty && !tuple.aisle.isEmpty && !tuple.section.isEmpty {
                isZoomOutRequired = false
            }
            return PluginAPIs.CompassAislePin(
                type: "user",
                id: UUID().uuidString,
                location: PluginAPIs.CompassAisleLocation(
                    zone: tuple.zone,
                    aisle: tuple.aisle,
                    section: tuple.section,
                    selected: tuple.selected
                )
            )
        }

        if isStaticPathVisible {
            let compassPins = aislePins.map { PluginAPIs.CompassPin.aisle($0) }
            compassAPI.displayStaticPath(
                pins: compassPins,
                startFromNearbyEntrance: true,
                disableZoomGestures: false
            )
        } else {
            var compassPins = aislePins.map { PluginAPIs.CompassPin.aisle($0) }
            // Append a sample campaign pin
            compassPins.append(.campaign(PluginAPIs.CompassCampaignPin(type: "campaign", id: 2)))
            compassAPI.displayPin(
                pins: compassPins,
                config: displayPinConfig.hashMap,
                isZoomOutRequired: isZoomOutRequired
            )
        }
    }

    func displayCampaignPinSample() {
        let compassPins: [PluginAPIs.CompassPin] = [
            .campaign(PluginAPIs.CompassCampaignPin(type: "campaign", id: 2, selected: false))
        ]
        compassAPI.displayPin(pins: compassPins, config: displayPinConfig.hashMap, isZoomOutRequired: false)
    }

    func getUserDistance(zone: String, aisle: String, section: String) {
        let trimmedZone = zone.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedAisle = aisle.trimmingCharacters(in: .whitespacesAndNewlines)
        let trimmedSection = section.trimmingCharacters(in: .whitespacesAndNewlines)

        guard !trimmedZone.isEmpty, !trimmedAisle.isEmpty, !trimmedSection.isEmpty else {
            consoleLog("Please provide zone, aisle, and section to calculate distance.")
            return
        }

        let location = PluginAPIs.CompassAisleLocation(
            zone: trimmedZone,
            aisle: trimmedAisle,
            section: trimmedSection,
            selected: true
        )
        let pin = PluginAPIs.CompassAislePin(
            type: "user_distance",
            id: UUID().uuidString,
            location: location
        )

        consoleLog("Requesting distance to \(trimmedZone)-\(trimmedAisle)-\(trimmedSection)")
        requestUserDistance(for: [pin])
    }

    func testGetUserDistanceWithHardcodedPin() {
        let pin = PluginAPIs.CompassAislePin(
            type: "item",
            id: "123",
            location: PluginAPIs.CompassAisleLocation(zone: "A", aisle: "1", section: "1", selected: true)
        )
        consoleLog("Called getUserDistance with hardcoded pin: \(pin)")
        requestUserDistance(for: [pin])
    }

    private func requestUserDistance(for pins: [PluginAPIs.CompassAislePin]) {
        guard !pins.isEmpty else { return }

        var updateStatus = true

        aislePinDropEventEmitterHandler = { pinDropEventEmitter in
            var dict = pinDropEventEmitter.toDictionary()
            dict["eventType"] = nil

            Log.debug("The value of aislePinDropEventEmitterHandler dict is:\(dict)")
            if let output = dict.toJSONString() {
                Log.debug("Display Pins Payload for Aisle: \(output)")
                DispatchQueue.main.async {
                    self.consoleLog("PIN DROP V2 EVENT:\n\(output)")
                }
            }

            guard updateStatus else {
                return
            }

            updateStatus = false
            Log.debug("displaypin success")
        }

        pinClickedEventEmitterHandler = { pinClickedEventEmitter in
            var dict = pinClickedEventEmitter.toDictionary()
            dict["eventType"] = nil
            Log.debug("The value of pinClickedEventEmitterHandler dict is:\(dict)")
            if let output = dict.toJSONString() {
                Log.debug("Pin Clicked: \(output)")
                DispatchQueue.main.async {
                    self.consoleLog("PIN CLICKED EVENT:\n\(output)")
                }
            }
        }

        compassAPI.getUserDistance(pins: pins) { responses in
            responses.forEach { response in
                let dict = response.data
                print("User distance response is: \(dict)")
                if let output = dict.toJSONString() {
                    DispatchQueue.main.async {
                        self.consoleLog("USER DISTANCE RESPONSE:\n\(output)")
                    }
                }
            }
        }
    }

    func setAndGetAssetsEventStatus() {
        var updateStatus = true

        pinDropEventEmitterHandler = { pinDropEventEmitter in
            var dict = pinDropEventEmitter.toDictionary()
            dict["eventType"] = nil
            Log.debug("The value of pinDropEventEmitterHandler dict is:\(dict)")
            if let output = dict.toJSONString() {
                Log.debug("Display Pins Payload for Asset or Generic: \(output)")
                DispatchQueue.main.async {
                    self.consoleLog("PIN DROP EVENT:\n\(output)")
                }
            }

            guard updateStatus else {
                return
            }

            updateStatus = false
            Log.debug("displaypin success")
        }

        errorEventEmitterHandler = { errorEventEmitter in
            let dict = errorEventEmitter.toDictionary()
            Log.debug("The value of errorEventEmitterHandler dict is:\(dict)")

            var event = [String: Any]()
            if let code = dict["errorCode"] as? Int {
                event["code"] = code
            }
            if let errortype = dict["compassErrorType"] as? String {
                event["errortype"] = errortype
            }
            if let message = dict["errorDescription"] as? String {
                event["message"] = message
            }
            Log.debug("SendEvent wih errorEventEmitter and body \(event)")
            DispatchQueue.main.async {
                self.consoleLog("ERROR EVENT:\n\(event.toJSONString() ?? "")")
            }
            guard updateStatus else {
                return
            }

            updateStatus = false
            Log.debug("-1 Compass displayPins failed")
        }
    }
}

extension HomeViewModel: CompassWebViewMessageDelegate {
    /// Conform to WebViewMessageDelegate to receive raw posted messages
    func didReceiveWebViewMessage(_ message: String) {
        Log.debug("Message from WebViewMessageDelegate (MessageParser): \(message)")
    }
}
