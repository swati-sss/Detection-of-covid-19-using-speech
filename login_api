import CoreGraphics
import Foundation

extension StoreMapLoaderViewModel {
    var navigationSessionState: NavigationSessionState? {
        indoorNavigationService.navigationSessionState
    }

    var isNavigationActiveOrStopped: Bool {
        guard let status = navigationSessionState?.navigationStatus else { return false }
        return status == .inProgress || status == .stopped
    }

    var shouldSkipZoomOnLocation: Bool {
        isNavigationActiveOrStopped &&
        (mapViewDelegate?.isCenterButtonClicked == false)
    }

    var isNavigationInProgress: Bool {
        navigationSessionState?.navigationStatus == .inProgress
    }

    var shouldUpdateNavigationRoute: Bool {
        guard let navigationSessionState = navigationSessionState else { return false }
        let isCurrentLocationWaypointNil = navigationSessionState.currentLocationWaypoint == nil
        let isNewRouteNeeded = isCurrentLocationWaypointNil ||
        indoorNavigationService.areNavigationRequiredPointsAvailable()
        let isInProgress = isCurrentLocationWaypointNil || navigationSessionState.navigationStatus == .inProgress
        return navigationEnabled == true && isNewRouteNeeded && isInProgress
    }

    func setNavigation(enabled: inout Bool) -> Bool {
        return indoorNavigationService.toggleNavigation(enabled: &enabled)
    }

    func canDisplayNavigationButton() -> Bool {
        return indoorNavigationService.navigationSessionState?.hasPinsOnMap ?? false
    }

    func setupNavigationPaths() {
        routeCancellable?.cancel()
        routeCancellable = indoorNavigationService.handleRouteUpdate(
            assetService: assetService,
            indoorPositioningService: indoorPositioningService,
            setPathfindingEnabled: { [weak self] enabled in
                guard let self, !isStaticPathVisible else { return }
                self.setPathfindingEnabled(enabled, duration: 0.2)
            },
            updateCustomRoute: { [weak self] coords, distance in
                guard let self, !isStaticPathVisible else { return }
                self.updateCustomRoute(coords: coords, distance: distance)
            }
        )
    }

    func updateNavigationRoute(
        with coordinates: [Point]?, at index: Int, using pinList: PinList?,
        renderPinsRequest: RenderPinsRequest?
    ) {
        Log.debug("[Navigation] enabled: \(String(describing: navigationEnabled)).")
        guard let navigationEnabled,
              navigationEnabled,
              let coordinates = coordinates,
              !coordinates.isEmpty,
              let converter = indoorPositioningService.floorCoordinatesConverter else {
            Log.debug("[Navigation] No coordinates found to add navigation route.")
            return
        }

        Log.debug("""
        [Navigation] Adding route coordinates (store map units): \(coordinates)
          - Index: \(index)
          - Floor selected: \(floorSelected)
          - Converting to Oriient units and requesting route API.
        """)

        self.indoorNavigationService.updateNavigationState(
            currentLocation: nil, pinWaypoint: nil,
            renderRequest: renderPinsRequest, pinListUpdate: pinList
        )

        coordinates.forEach {
            let transformedPoint = CGPoint(x: $0.x, y: $0.y)
                .storeMapToWasp(offset: assetService.storeConfigOffset)
                .convertToOriient(using: converter)
                .asCGPoint()

            let roundedPoint = CGPoint(
                x: transformedPoint.x.rounded(toDecimalPlaces: 1),
                y: transformedPoint.y.rounded(toDecimalPlaces: 1)
            )
            self.indoorNavigationService.addWaypoint(
                at: index, coordinate: roundedPoint, floorSelected: floorSelected
            )
        }
    }

    func updateStaticPathRoute(with coordinates: [Point]?) {
        guard let coordinates = coordinates,
              !coordinates.isEmpty,
              let converter = indoorPositioningService.floorCoordinatesConverter else {
            Log.debug("[DisplayStaticPath] No coordinates found to add navigation route.")
            return
        }

        Log.debug(
                """
                [DisplayStaticPath] Adding route coordinates (store map units): \(coordinates)
                  - Floor selected: \(floorSelected)
                  - Converting to Oriient units and requesting route API.
                """
        )

        coordinates.enumerated().forEach {
            let transformedPoint = CGPoint(x: $1.x, y: $1.y)
                .storeMapToWasp(offset: assetService.storeConfigOffset)
                .convertToOriient(using: converter)
                .asCGPoint()

            let roundedPoint = CGPoint(
                x: transformedPoint.x.rounded(toDecimalPlaces: 1),
                y: transformedPoint.y.rounded(toDecimalPlaces: 1)
            )
            self.staticPathPreviewService.addWaypoint(
                coordinate: roundedPoint,
                floorSelected: floorSelected,
                shouldFetchRoute: coordinates.count == $0+1
            )
        }
    }

    func setPathfindingEnabled(_ enabled: Bool, duration: TimeInterval = 0.0, force: Bool = false) {
        let performRequest = {
            self.request(.setPathfindingEnabled(SetPathFindingRequest(pathfinderEnabled: enabled)))
        }

        if force {
            DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: performRequest)
            return
        }

        if isStaticPathVisible {
            DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: performRequest)
            return
        }

        guard lastPathfindingEnabled != enabled,
              let navigationEnabled,
              navigationEnabled else {
            return
        }

        lastPathfindingEnabled = enabled
        Log.info("[Navigation or DisplayStaticPath] Set pathfinding enabled: \(enabled).")
        DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: performRequest)
    }

    func setPinSelectionEnabled(_ enabled: Bool) {
        Log.info("Set pinSelection enabled: \(enabled).")
        self.request(.setPinSelectionEnabled(SetPinSelectionRequest(pinSelectionEnabled: enabled)))
    }

    func updateCustomRoute(coords: [Coord], distance: Double) {
        let shouldRequest = distance.isNaN || (navigationEnabled ?? false)

        guard shouldRequest else { return }

        Log.info("[Navigation or DisplayStaticPath] Update custom route with coord: \(coords), distance: \(distance).")
        request(.customRoute(CustomRouteRequest(coords: coords, distance: distance, useBluedot: !isStaticPathVisible)))
    }

    func displayStaticPath(
        using renderPinsRequest: RenderPinsRequest,
        startFromNearbyEntrance: Bool,
        disableZoomGestures: Bool
    ) {
        staticPathPreviewService.previewWaypoints = []
        showMapZoomedOut()
        isStaticPathVisible = true
        staticPathPreviewService.startFromNearbyEntrance = startFromNearbyEntrance
        setPinSelectionEnabled(false)
        mapViewDelegate?.displayPinErrorBanner(false)

        request(.renderPins(renderPinsRequest))
        mapViewDelegate?.previewSetUp(isStaticPathVisible: true)
        self.mapViewDelegate?.updateZoomInteraction(enabled: !disableZoomGestures)

        staticPathPreviewCancellable?.cancel()
        staticPathPreviewCancellable = staticPathPreviewService.handleRouteUpdate(
            assetService: assetService,
            indoorPositioningService: indoorPositioningService) { [weak self] enabled in
                self?.setPathfindingEnabled(enabled)
        } updateCustomRoute: { [weak self] coords in
            self?.updateCustomRoute(coords: coords, distance: .nan)
        }
    }

    func updateStaticPathIfNeeded(for pinRenderedMessage: PinRenderedMessage) {
        guard let pins = pinRenderedMessage.pins,
              !pins.isEmpty,
              isStaticPathVisible else {
            return
        }

        let validPins = pins.filter { $0.errorData == nil }

        guard validPins == pins else {
            mapViewDelegate?.displayPinErrorBanner(true)
            setPathfindingEnabled(false, force: true)
            return
        }

        var pointList: [Point] = []
        if staticPathPreviewService.startFromNearbyEntrance,
           let entrance = mapLoadedData?.entrances.first {
            pointList.append(Point(x: entrance.x, y: entrance.y))
        }

        pointList += validPins.compactMap { $0.location.map { Point(x: $0.x, y: $0.y) } }

        if !validPins.isEmpty {
            updateStaticPathRoute(with: pointList)
        }
    }

    func updateUserPosition(x: Double, y: Double, accuracy: CGFloat?) {
        request(.showUserLocation(UserPosition(x: x, y: y, ringRadius: accuracy)))

        guard shouldUpdateNavigationRoute else { return }

        let pointList = [Point(x: x, y: y)]
        updateNavigationRoute(with: pointList, at: 0, using: nil, renderPinsRequest: nil)
    }

    func updateUserRotation(angle: CGFloat, rotateMap: Bool) {
        guard !isStaticPathVisible else { return }
        request(.rotateUser(UserRotation(angle: angle, rotateMap: rotateMap)))
    }

    func updateUserLoading(percentage: Int) {
        request(.showUserLoading(UserLoading(
            percentage: (percentage == 0) ? 1 : percentage))
        )
    }

    func clearRenderedPin(mapConfig: MapConfig) {
        Log.debug("Clear pins")
        clearStaticPath()

        request(.renderXYLocationPinRequested(PinList(pins: [])))
        request(.renderPins(RenderPinsRequest(pins: [], pinGroupingEnabled: pinsConfig.groupPinsEnabled)))
        indoorNavigationService.resetWaypoints(shouldClearBlueDot: false, shouldClearPinList: true)
        indoorNavigationService.resetNavigationSessionState()
        mapViewDelegate?.handleNavigationInterruption(for: 1, status: navigationSessionState?.navigationStatus)

        if mapConfig.resetZoom {
            Log.debug("Reset Zoom level")
            showMapZoomedOut()
        }
    }

    func clearStaticPath() {
        isStaticPathVisible = false
        mapViewDelegate?.displayPinErrorBanner(false)
        setPinSelectionEnabled(true)
        mapViewDelegate?.previewSetUp(isStaticPathVisible: false)
        self.mapViewDelegate?.updateZoomInteraction(enabled: true)
        setPathfindingEnabled(false, force: true)
    }
}

// MARK: - IndoorNavigationServiceDelegate
extension StoreMapLoaderViewModel: IndoorNavigationServiceDelegate {
    func requestRenderPins(_ pins: [Pin]?, pinList: PinList?, navigationEvent: NavigationAnalytics.Event?) {
        if let pins = pins {
            request(.renderPins(.init(pins: pins, pinGroupingEnabled: pinsConfig.groupPinsEnabled)))

            guard let position = indoorPositioningService.lastPosition.value,
                  position.isLocked else {
                Log.info("[Navigation] The value of lastLockedPosition is nil")
                return
            }

            guard let converter = indoorPositioningService.floorCoordinatesConverter else {
                Log.info("[Navigation] The value of floorCoordinatesConverter is nil")
                return
            }

            let compassPosition = position.convertToCompass(using: converter).asCGPoint()

            let payload = NavigationAnalytics(
                event: navigationEvent,
                location: NavigationAnalytics.Location(x: compassPosition.x, y: compassPosition.y)
            )

            Analytics.mapNavigation(payload: payload)
        } else if let pinList = pinList {
            request(.renderXYLocationPinRequested(pinList))
        }
    }

    func refreshNavigationButtonState(_ isVisible: Bool?) {
        mapViewDelegate?.refreshNavigationButtonState(isVisible)
    }
}

final class NavigationCoordinator {
    private unowned let viewModel: StoreMapLoaderViewModel

    init(viewModel: StoreMapLoaderViewModel) {
        self.viewModel = viewModel
    }

    func handleAislePinNavigation(_ pinRenderedMessage: PinRenderedMessage) {
        guard !viewModel.isStaticPathVisible,
              let pins = pinRenderedMessage.pins,
              !pins.isEmpty,
              viewModel.navigationEnabled == true else {
            viewModel.mapViewDelegate?.refreshNavigationButtonState(false)
            return
        }

        let indoorNavigationService = viewModel.indoorNavigationService
        indoorNavigationService.resetWaypoints(shouldClearBlueDot: false, shouldClearPinList: true)

        let validPins = pins.filter { $0.selected && $0.errorData == nil }
        let pointList = validPins.compactMap { $0.location.map { Point(x: $0.x, y: $0.y) } }
        let shouldUpdatePinList = indoorNavigationService.navigationSessionState?.navigationStatus != .inProgress

        let renderPinsRequest: RenderPinsRequest? = shouldUpdatePinList ? .init(
            pins: pins,
            pinGroupingEnabled: viewModel.pinsConfig.groupPinsEnabled
        ) : nil

        indoorNavigationService.updateNavigationState(
            currentLocation: nil,
            pinWaypoint: nil,
            renderRequest: renderPinsRequest,
            pinListUpdate: nil
        )

        viewModel.mapViewDelegate?.handleNavigationInterruption(
            for: 1,
            status: viewModel.navigationSessionState?.navigationStatus
        )

        if !validPins.isEmpty {
            startAutomaticNavigationIfNeeded()
            viewModel.updateNavigationRoute(
                with: pointList,
                at: 1,
                using: nil,
                renderPinsRequest: renderPinsRequest
            )
        } else {
            indoorNavigationService.resetNavigationSessionState()
        }

        refreshNavigationState(withPins: pins)
    }

    func handleXYPinNavigation(pins: [DrawPin], topLeft: Point?, bottomRight: Point?) {
        guard !pins.isEmpty else {
            viewModel.mapViewDelegate?.refreshNavigationButtonState(false)
            return
        }

        let indoorNavigationService = viewModel.indoorNavigationService
        indoorNavigationService.resetWaypoints(shouldClearBlueDot: false, shouldClearPinList: true)

        let validPins = pins.filter { $0.errorData == nil }
        let shouldUpdatePinList = indoorNavigationService.navigationSessionState?.navigationStatus != .inProgress
        let currentPinList = shouldUpdatePinList ? PinList(pins: validPins) : nil

        indoorNavigationService.updateNavigationState(
            currentLocation: nil,
            pinWaypoint: nil,
            renderRequest: nil,
            pinListUpdate: currentPinList
        )

        viewModel.mapViewDelegate?.handleNavigationInterruption(
            for: 1,
            status: viewModel.navigationSessionState?.navigationStatus
        )

        if !validPins.isEmpty {
            let pointList = validPins.map { Point(x: $0.x, y: $0.y) }
            viewModel.updateNavigationRoute(
                with: pointList,
                at: 1,
                using: currentPinList,
                renderPinsRequest: nil
            )
        } else {
            indoorNavigationService.resetNavigationSessionState()
        }

        refreshNavigationState(withDrawPins: pins)
        viewModel.zoomOnLocation(topLeft: topLeft, bottomRight: bottomRight)
    }

    private func refreshNavigationState(withPins pins: [Pin]) {
        let validPins = pins.filter { $0.errorData == nil }
        let hasPinsOnMap = !validPins.isEmpty
        viewModel.indoorNavigationService.navigationSessionState?.hasPinsOnMap = hasPinsOnMap
        viewModel.mapViewDelegate?.refreshNavigationButtonState(hasPinsOnMap)
    }

    private func refreshNavigationState(withDrawPins drawPins: [DrawPin]) {
        let validPins = drawPins.filter { $0.errorData == nil }
        let hasPinsOnMap = !validPins.isEmpty
        viewModel.indoorNavigationService.navigationSessionState?.hasPinsOnMap = hasPinsOnMap
        viewModel.mapViewDelegate?.refreshNavigationButtonState(hasPinsOnMap)
    }

    private func startAutomaticNavigationIfNeeded() {
        guard let navigationConfig = viewModel.indoorNavigationService.navigationConfig,
              navigationConfig.isAutomaticNavigation else {
            return
        }

        viewModel.indoorNavigationService.navigationSessionState?.navigationStatus = .inProgress
        viewModel.setPathfindingEnabled(true, duration: 0.2, force: true)
    }
}
