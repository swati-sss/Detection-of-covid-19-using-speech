// Enhanced ScanResultView.swift - Main Image Content with spotlight effect

private var mainImageContent: some View {
    GeometryReader { geometry in
        ZStack {
            // Base image (will be darkened)
            if let capturedImage = capturedImage {
                Image(uiImage: capturedImage)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: geometry.size.width, height: geometry.size.height)
            } else {
                Image("section4")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: geometry.size.width, height: geometry.size.height)
            }
            
            // Dark overlay over entire image
            Rectangle()
                .fill(Color.black.opacity(0.6))
                .frame(width: geometry.size.width, height: geometry.size.height)
                .mask(
                    // Create inverse mask - everything EXCEPT the bounding boxes
                    ZStack {
                        // Full rectangle (everything gets darkened)
                        Rectangle()
                            .fill(Color.white)
                        
                        // Cut out holes for bounding boxes (these areas stay bright)
                        if let response = viewModel.modHealthResponse {
                            Group {
                                if filterState.showMissing {
                                    ForEach(Array(response.safeMissingItems.enumerated()), id: \.offset) { index, item in
                                        BoundingBoxMask(item: item, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                                    }
                                }
                                
                                if filterState.showMisplaced {
                                    ForEach(Array(response.safeMisplacedItems.enumerated()), id: \.offset) { index, item in
                                        BoundingBoxMask(item: item, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                                    }
                                }
                                
                                if filterState.showUnknown {
                                    ForEach(Array(response.safeUnknownItems.enumerated()), id: \.offset) { index, item in
                                        BoundingBoxMask(item: item, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                                    }
                                }
                                
                                if filterState.showCorrect {
                                    ForEach(Array(response.safeCorrectItems.enumerated()), id: \.offset) { index, item in
                                        BoundingBoxMask(item: item, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                                    }
                                }
                            }
                            .blendMode(.destinationOut) // This cuts holes in the mask
                        }
                    }
                )
            
            // Bounding box strokes (on top of everything)
            if let response = viewModel.modHealthResponse {
                if filterState.showMissing {
                    ForEach(Array(response.safeMissingItems.enumerated()), id: \.offset) { index, item in
                        BoundingBoxStroke(item: item, color: .red, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                    }
                }
                
                if filterState.showMisplaced {
                    ForEach(Array(response.safeMisplacedItems.enumerated()), id: \.offset) { index, item in
                        BoundingBoxStroke(item: item, color: .yellow, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                    }
                }
                
                if filterState.showUnknown {
                    ForEach(Array(response.safeUnknownItems.enumerated()), id: \.offset) { index, item in
                        BoundingBoxStroke(item: item, color: .orange, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                    }
                }
                
                if filterState.showCorrect {
                    ForEach(Array(response.safeCorrectItems.enumerated()), id: \.offset) { index, item in
                        BoundingBoxStroke(item: item, color: .green, imageSize: geometry.size, originalImageDimensions: imageDimensions)
                    }
                }
            }
        }
    }
}

// New component for creating mask shapes (invisible rectangles for cutting holes)
struct BoundingBoxMask: View {
    let item: ModHealthItem
    let imageSize: CGSize
    let originalImageDimensions: CGSize
    
    var body: some View {
        if let xMinStr = item.xMin,
           let xMaxStr = item.xMax,
           let yMinStr = item.yMin,
           let yMaxStr = item.yMax,
           let xMin = Double(xMinStr),
           let xMax = Double(xMaxStr),
           let yMin = Double(yMinStr),
           let yMax = Double(yMaxStr) {
            
            let scaleX = imageSize.width / originalImageDimensions.width
            let originalHeightScaled = originalImageDimensions.height * scaleX
            let letterboxAmount = (imageSize.height - originalHeightScaled) / 2
            let scaleY = scaleX
            
            let boxX = CGFloat(xMin) * scaleX
            let boxY = (CGFloat(yMin) * scaleY) + letterboxAmount
            let boxWidth = CGFloat(xMax - xMin) * scaleX
            let boxHeight = CGFloat(yMax - yMin) * scaleY
            
            Rectangle()
                .fill(Color.white) // White fills cut holes in the mask
                .frame(width: boxWidth, height: boxHeight)
                .position(x: boxX + boxWidth/2, y: boxY + boxHeight/2)
        }
    }
}

// Separate component for just the stroke borders
struct BoundingBoxStroke: View {
    let item: ModHealthItem
    let color: Color
    let imageSize: CGSize
    let originalImageDimensions: CGSize
    
    var body: some View {
        if let xMinStr = item.xMin,
           let xMaxStr = item.xMax,
           let yMinStr = item.yMin,
           let yMaxStr = item.yMax,
           let xMin = Double(xMinStr),
           let xMax = Double(xMaxStr),
           let yMin = Double(yMinStr),
           let yMax = Double(yMaxStr) {
            
            let scaleX = imageSize.width / originalImageDimensions.width
            let originalHeightScaled = originalImageDimensions.height * scaleX
            let letterboxAmount = (imageSize.height - originalHeightScaled) / 2
            let scaleY = scaleX
            
            let boxX = CGFloat(xMin) * scaleX
            let boxY = (CGFloat(yMin) * scaleY) + letterboxAmount
            let boxWidth = CGFloat(xMax - xMin) * scaleX
            let boxHeight = CGFloat(yMax - yMin) * scaleY
            
            Rectangle()
                .stroke(color, lineWidth: 4)
                .frame(width: boxWidth, height: boxHeight)
                .position(x: boxX + boxWidth/2, y: boxY + boxHeight/2)
        }
    }
}

// Alternative approach with glow effect for even better visibility
struct BoundingBoxStrokeWithGlow: View {
    let item: ModHealthItem
    let color: Color
    let imageSize: CGSize
    let originalImageDimensions: CGSize
    
    var body: some View {
        if let xMinStr = item.xMin,
           let xMaxStr = item.xMax,
           let yMinStr = item.yMin,
           let yMaxStr = item.yMax,
           let xMin = Double(xMinStr),
           let xMax = Double(xMaxStr),
           let yMin = Double(yMinStr),
           let yMax = Double(yMaxStr) {
            
            let scaleX = imageSize.width / originalImageDimensions.width
            let originalHeightScaled = originalImageDimensions.height * scaleX
            let letterboxAmount = (imageSize.height - originalHeightScaled) / 2
            let scaleY = scaleX
            
            let boxX = CGFloat(xMin) * scaleX
            let boxY = (CGFloat(yMin) * scaleY) + letterboxAmount
            let boxWidth = CGFloat(xMax - xMin) * scaleX
            let boxHeight = CGFloat(yMax - yMin) * scaleY
            
            ZStack {
                // Glow effect
                Rectangle()
                    .stroke(color, lineWidth: 8)
                    .opacity(0.3)
                    .blur(radius: 4)
                
                // Main stroke
                Rectangle()
                    .stroke(color, lineWidth: 4)
            }
            .frame(width: boxWidth, height: boxHeight)
            .position(x: boxX + boxWidth/2, y: boxY + boxHeight/2)
        }
    }
}
