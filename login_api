import Foundation
//import UIKit
import compass_sdk_ios
import Combine
import os.log

var compass: Compass?

typealias PinDropEventEmitterHandler = (PinDropEventEmitter) -> Void
typealias EventEmitterDescriptionHandler = (EventEmitterDescription) -> Void
typealias LocationEventEmitterHandler = (LocationEventEmitter) -> Void
typealias ErrorEventEmitterHandler = (ErrorEventEmitter) -> Void

@objc(CompassSdkRn)
class CompassSdkRn: RCTEventEmitter {
  var isListenerRegistered = false
  private let log = OSLog.init(subsystem: Bundle.main.bundleIdentifier ?? "com.compass.map", category: "compasssdkapi")
  var currentStore: Int?
  var statusService: StatusService?
  private var pinDropEventEmitterHandler: PinDropEventEmitterHandler?
  private var showMapEventEmitterHandler: EventEmitterDescriptionHandler?
  private var bootstrapEventEmitterHandler: EventEmitterDescriptionHandler?
  private var locationEventEmitterHandler: LocationEventEmitterHandler?
  private var errorEventEmitterHandler: ErrorEventEmitterHandler?
  private var cancellables = Set<AnyCancellable>()
  
  enum Event: String, CaseIterable {
    case compassStatusEvent = "COMPASS_STATUS_EVENT"
    case compassErrorEvent = "COMPASS_ERROR_EVENT"
    case compassLogEvent = "COMPASS_LOG_EVENT"
    case pinCallbackEvent = "PIN_CALLBACK_EVENT"
    case compassMapEvent = "COMPASS_MAP_EVENT"
    case compassAssetsEvent = "COMPASS_ASSETS_EVENT"
  }
  
  override func startObserving() {
    os_log("Compass: startObserving", log: self.log)
    isListenerRegistered = true
    super.startObserving()
  }
  
  override func stopObserving() {
    os_log("Compass: stopObserving", log: self.log)
    isListenerRegistered = false
    super.stopObserving()
  }
  
  override func supportedEvents() -> [String]! {
    return Event.allCases.map { $0.rawValue }
  }
  
  @objc(initialize:consumerID:accountID:tokenType:storeId:environment:config:resolve:reject:)
  func initialize(clientSec: String,
                  consumerID: String,
                  accountID: String,
                  tokenType: String,
                  storeId: Int,
                  environment: String,
                  config: AnyObject?,
                  resolve: @escaping RCTPromiseResolveBlock,
                  reject: @escaping RCTPromiseRejectBlock) -> Void {
    DispatchQueue.main.async { [weak self] in
      self?.currentStore = compass?.currentStore
      guard let self = self else {
        let err = NSError(domain: "Bridge file error",
                          code: -1,
                          userInfo: ["description":"rn: PresentedViewController is nil"])
        os_log("Compass: PresentedViewController is nil")
        reject("\(err.code)", err.debugDescription, err)
        return
      }
      
      guard self.currentStore != storeId else {
        resolve("Compass Initialization success")
        return
      }
      
      compass = Compass()
      
      guard let compass = compass else {
        resolve("Compass Initialization success")
        return
      }
      
      self.statusService = compass.getStatusService()
      // Do any additional setup after loading the view.
      let timestamp = String(Int(1000 * Date().timeIntervalSince1970))
      let authParameter = AuthParameter(authToken: clientSec,
                                        tokenType: tokenType,
                                        accountID: accountID,
                                        consumerID: consumerID)
      
      var configuration = Configuration(country: "US",
                                        site: storeId,
                                        userId: accountID,
                                        siteType: SiteType.Store,
                                        manualPinDrop: true,
                                        navigateToPin: false,
                                        multiPin: false,
                                        searchBar: false,
                                        centerMap: true,
                                        locationIngestion: true,
                                        mockUser: false,
                                        anonymizedUserID: "ANNONYMIZEDUSER",
                                        startPositioning: true,
                                        automaticCalibration: true,
                                        businessUnitType: BusinessUnitType.WALMART)
      
      if let configDict = config as? [String: Bool], let mockUser = configDict["mockUser"] {
        configuration.mockUser = mockUser
      }
      
      var updateStatus = true
      let isProdEnv = environment.lowercased().contains("prod") || environment.lowercased().contains("beta")
      compass.setEnvironment(isProdEnv ? .production : .staging)
      
      self.cancellables.removeAll()
      Just(compass.initialize(authParameter: authParameter,
                              configuration: configuration,
                              capabilities: [],
                              rootViewController: ViewController.shared))
      .eraseToAnyPublisher()
      .flatMap { _ in
        compass.isFinishedInitialize
      }
      .sink { isFinishedInitialize in
        guard let isFinishedInitialize else {
          os_log("Compass: Compass waiting initialization", log: self.log)
          return
        }
        
        guard isFinishedInitialize else {
          Log.debug("Compass: Compass Initialization Failed")
          let err = NSError(
            domain: "Unknown error",
            code: -1,
            userInfo: ["description": "Unknown error while initializing compass."]
          )
          updateStatus = false
          reject("\(err.code)", err.debugDescription, err)
          return
        }
        
        self.currentStore = storeId
        compass.currentStore = storeId
        os_log("Compass: Compass initialization is success", log: self.log)
        
        if updateStatus {
          updateStatus = false
          resolve("Compass Initialization success")
        }
      }
      .store(in: &self.cancellables)
      
      self.statusService?.eventEmitterHandler = { [weak self] eventEmitter in
        guard let self else { return }
        switch eventEmitter.eventType {
        case .mapStatusEventEmitter:
          guard let mapStatusEvent = eventEmitter as? MapStatusEventEmitter else {
            return
          }
          var dict = mapStatusEvent.toDictionary()
          dict["eventType"] = nil
          self.send(.compassMapEvent, dict: dict)
        case .positionEventEmitter:
          guard let positionEvent = eventEmitter as? PositionEventEmitter else {
            return
          }
          
          var event = [String : Any]()
          event["EventType"] = positionEvent.positionType
          event["EventCode"] = positionEvent.positionCode
          
          os_log("Compass: compassProgressEvent %{public}@ %{public}@",
                 log: self.log,
                 event,
                 eventEmitter.eventType.rawValue)
          
          if self.isListenerRegistered {
            self.sendEvent(withName: Event.compassStatusEvent.rawValue, body: event)
          }
        case .initErrorEventEmitter:
          guard self.isListenerRegistered, let compassError = eventEmitter as? ErrorEventEmitter else {
            return
          }
          var event = [String : Any]()
          event["code"] = compassError.errorCode
          event["errortype"] = compassError.compassErrorType
          event["message"] = compassError.errorDescription
          
          self.sendEvent(withName: Event.compassErrorEvent.rawValue, body: event)
          
          if updateStatus {
            updateStatus = false
            reject("-1", "Compass Initialization failed", nil)
          }
        case .pinListEventEmitter:
          guard let pinDropEventEmitter = eventEmitter as? PinDropEventEmitter else {
            return
          }
          
          self.pinDropEventEmitterHandler?(pinDropEventEmitter)
        case .showMapEventEmitter:
          guard let eventEmitterDescription = eventEmitter as? EventEmitterDescription else {
            return
          }
          
          self.showMapEventEmitterHandler?(eventEmitterDescription)
        case .bootstrapEventEmitter:
          guard let eventEmitterDescription = eventEmitter as? EventEmitterDescription else {
            return
          }
          
          self.bootstrapEventEmitterHandler?(eventEmitterDescription)
        case .locationEventEmitter:
          guard let locationEventEmitter = eventEmitter as? LocationEventEmitter else {
            return
          }
          
          self.locationEventEmitterHandler?(locationEventEmitter)
        case .errorEventEmitter:
          guard let errorEventEmitter = eventEmitter as? ErrorEventEmitter else {
            return
          }
          
          self.errorEventEmitterHandler?(errorEventEmitter)
        default:
          break
        }
      }
    }
  }
  
  @objc(getCompassStatus:reject:)
  func getCompassStatus(resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) -> Void {
    //TODO
    let err = NSError(domain: "Bridge file error",
                      code: -1,
                      userInfo: ["description":"getCompassStatus is not implemented"])
    reject("\(err.code)", err.debugDescription, err)
  }
  
  @objc(displayPins:type:config:resolve:reject:)
  func displayPins(uuid: [String],
                   type: String,
                   config: [String: Any]?,
                   resolve: @escaping RCTPromiseResolveBlock,
                   reject: @escaping RCTPromiseRejectBlock) -> Void {
    DispatchQueue.main.async { [weak self] in
      os_log("Compass: displayPins called.")
      guard let self = self, let compass = compass else {
        let err = NSError(domain: "Bridge file error",
                          code: -1,
                          userInfo: ["description":"rn: PresentedViewController is nil"])
        reject("\(err.code)", err.debugDescription, err)
        return
      }
      
      var updateStatus = true
      
      compass.isFinishedInitialize
        .sink { [weak self] isFinishedInitialize in
          guard let self,
                self.checkCompassInitialization(isFinishedInitialize, reject: reject) else {
            return
          }
          
          var firstUuid = [String]()
          if uuid.count > 0, let first = uuid.first {
            firstUuid = [first]
          }
          var idType: EventConstant.Identifier
          switch type.lowercased() {
          case "assets", "asset":
            idType = EventConstant.Identifier.assets
          default:
            idType = EventConstant.Identifier.generic
          }
          compass.displayPin(uuidList: firstUuid, idType: idType, config: config)
          debugPrint("uuid is \(uuid) firstUuid is \(firstUuid) and type is \(type)")
        }
        .store(in: &self.cancellables)
      
      
      //Observe error and progress update
      self.pinDropEventEmitterHandler = { [weak self] pinDropEventEmitter in
        guard let self else { return }
        var dict = pinDropEventEmitter.toDictionary()
        dict["eventType"] = nil
        os_log("Compass: compassAssetEvent %{public}@ %{public}@",
               log: self.log,
               dict,
               pinDropEventEmitter.eventType.rawValue)
        
        self.sendEvent(withName: Event.pinCallbackEvent.rawValue, body: dict)
        
        if updateStatus {
          updateStatus = false
          resolve("displaypin success")
        }
      }
      
      self.errorEventEmitterHandler = { [weak self] errorEventEmitter in
        guard let self, self.isListenerRegistered else {
          return
        }
        var event = [String : Any]()
        event["code"] = errorEventEmitter.errorCode
        event["errortype"] = errorEventEmitter.compassErrorType
        event["message"] = errorEventEmitter.errorDescription
        os_log("Compass: displayPins error %{public}@ %{public}@",
               log: self.log,
               event,
               errorEventEmitter.eventType.rawValue)
        
        self.sendEvent(withName: Event.compassErrorEvent.rawValue,
                       body: event)
        
        if updateStatus {
          updateStatus = false
          reject("-1", "Compass displayPins failed", nil)
        }
      }
    }
  }
  
  
  @objc(displayPinsV2:config:resolve:reject:)
  func displayPinsV2(pins: [[String: Any]],
                     config: [String: Any],
                     resolve: @escaping RCTPromiseResolveBlock,
                     reject: @escaping RCTPromiseRejectBlock) -> Void {
    DispatchQueue.main.async { [weak self] in
      os_log("Compass: displayPinsV2 called.")
      guard let self = self, let compass = compass else {
        let err = NSError(domain: "Bridge file error",
                          code: -1,
                          userInfo: ["description":"rn: PresentedViewController is nil"])
        reject("\(err.code)", err.debugDescription, err)
        return
      }
      
      var updateStatus = true
      
      compass.isFinishedInitialize
        .sink { [weak self] isFinishedInitialize in
          guard let self,
                self.checkCompassInitialization(isFinishedInitialize, reject: reject) else {
            return
          }
          
          var nativePins: [compass_sdk_ios.AislePin] = []
          for pin in pins {
            guard let type = pin["type"] as? String,
                  let id = pin["id"] as? String,
                  let location = pin["location"] as? [String: Any],
                  let zone = location["zone"] as? String,
                  let aisle = location["aisle"] as? String,
                  let section = location["section"] as? String
            else {
              let pinError = NSError(domain: "Bridge file error",
                                     code: -1,
                                     userInfo: ["description":"rn: displayPinsV2 failed due to invalid pin data"])
              reject("\(pinError.code)", pinError.localizedDescription, pinError)
              return
            }
            
            let aisleLocation = compass_sdk_ios.AisleLocation(zone: zone, aisle: aisle, section: section, selected: true)
            let nativePin = compass_sdk_ios.AislePin(type: type, id: id, location: aisleLocation)
            nativePins.append(nativePin)
          }
          
          compass.displayPinV2(pins: nativePins, config: config)
          debugPrint("Pins: \(pins) \nNativePins: \(nativePins)")
        }
        .store(in: &self.cancellables)
      
      //Observe error and progress update
      self.pinDropEventEmitterHandler = { [weak self] pinDropEventEmitter in
        guard let self else { return }
        var dict = pinDropEventEmitter.toDictionary()
        dict["eventType"] = nil
        os_log("Compass: compassAssetEvent %{public}@ %{public}@",
               log: self.log,
               dict,
               pinDropEventEmitter.eventType.rawValue)
        
        self.sendEvent(withName: Event.pinCallbackEvent.rawValue, body: dict)
        
        if updateStatus {
          updateStatus = false
          resolve("displaypin success")
        }
      }
      
      self.errorEventEmitterHandler = { [weak self] errorEventEmitter in
        guard let self, self.isListenerRegistered else {
          return
        }
        var event = [String : Any]()
        event["code"] = errorEventEmitter.errorCode
        event["errortype"] = errorEventEmitter.compassErrorType
        event["message"] = errorEventEmitter.errorDescription
        os_log("Compass: displayPinsV2 error %{public}@ %{public}@",
               log: self.log,
               event,
               errorEventEmitter.eventType.rawValue)
        
        self.sendEvent(withName: Event.compassErrorEvent.rawValue,
                       body: event)
        
        if updateStatus {
          updateStatus = false
          reject("-1", "Compass displayPinsV2 failed", nil)
        }
      }
    }
  }
  
  @objc(getUserDistance:resolve:reject:)
  func getUserDistance(pins: [[String: Any]],
                       resolve: @escaping RCTPromiseResolveBlock,
                       reject: @escaping RCTPromiseRejectBlock) -> Void {
    DispatchQueue.main.async { [weak self] in
      os_log("Compass: getUserDistance called.")
      guard let self = self, let compass = compass else {
        let err = NSError(domain: "Bridge file error",
                          code: -1,
                          userInfo: ["description":"rn: PresentedViewController is nil"])
        reject("\(err.code)", err.debugDescription, err)
        return
      }
      
      compass.isFinishedInitialize
        .sink { [weak self] isFinishedInitialize in
          guard let self,
                self.checkCompassInitialization(isFinishedInitialize, reject: reject) else {
            return
          }
          
          var nativePins: [compass_sdk_ios.AislePin] = []
          for pin in pins {
            guard let type = pin["type"] as? String,
                  let id = pin["id"] as? String,
                  let location = pin["location"] as? [String: Any],
                  let zone = location["zone"] as? String,
                  let aisle = location["aisle"] as? String,
                  let section = location["section"] as? String
            else {
              let pinError = NSError(domain: "Bridge file error",
                                     code: -1,
                                     userInfo: ["description":"rn: getUserDistance failed due to invalid pin data"])
              reject("\(pinError.code)", pinError.localizedDescription, pinError)
              return
            }
            
            let aisleLocation = compass_sdk_ios.AisleLocation(zone: zone, aisle: aisle, section: section, selected: true)
            let nativePin = compass_sdk_ios.AislePin(type: type, id: id, location: aisleLocation)
            nativePins.append(nativePin)
          }
          
          compass.getUserDistance(pins: nativePins) { distances in
            if distances.isEmpty {
              let distanceError = NSError(domain: "Bridge file error",
                                          code: -1,
                                          userInfo: ["description":"rn: getUserDistance failed due to empty distances"])
              os_log("Compass: getUserDistance failed with empty distances", log: self.log)
              reject("\(distanceError.code)", distanceError.localizedDescription, distanceError)
              return
            }
            
            let dictionaryList = distances.map { $0.toDictionary() }
            resolve(dictionaryList)
          }
        }
        .store(in: &self.cancellables)
    }
  }
    
    @objc(getLocation:resolve:reject:)
    func getLocation(assetId: String,
                     resolve: @escaping RCTPromiseResolveBlock,
                     reject: @escaping RCTPromiseRejectBlock) {
      DispatchQueue.main.async { [weak self] in
        guard let self = self, let compass = compass else {
          let err = NSError(domain: "Bridge file error",
                            code: -1,
                            userInfo: ["description":"rn: PresentedViewController is nil"])
          reject("\(err.code)", err.debugDescription, err)
          return
        }
        
        compass.isFinishedInitialize.sink { [weak self] isFinishedInitialize in
          guard let self,
                self.checkCompassInitialization(isFinishedInitialize, reject: reject) else {
            return
          }
          
          compass.getAisle(id: assetId)
        }
        .store(in: &self.cancellables)
        
        var isCancelled = false
        
        //Observe error and progress update
        self.locationEventEmitterHandler = { [weak self] locationEventEmitter in
          guard let self else { return }
          
          os_log("Compass: getAisle %{public}@ %{public}@",
                 log: self.log,
                 locationEventEmitter.location,
                 locationEventEmitter.eventType.rawValue)
          isCancelled = true
          resolve(["aisle" : locationEventEmitter.location])
        }
        
        guard !isCancelled else {
          return
        }
        self.errorEventEmitterHandler = { [weak self] errorEventEmitter in
          guard let self else { return }
          
          var event = [String : Any]()
          event["code"] = errorEventEmitter.errorCode
          event["errortype"] = errorEventEmitter.compassErrorType
          event["message"] = errorEventEmitter.errorDescription
          
          self.sendEvent(withName: Event.compassErrorEvent.rawValue,
                         body: event)
          
          os_log("Compass: getAisle error %{public}@ %{public}@",
                 log: self.log,
                 event,
                 errorEventEmitter.eventType.rawValue)
          
          reject("-1", "Compass getLocation failed", nil)
        }
      }
    }
    
  @objc(clearMap:)
  func clearMap(config: [String: Any]) {
    DispatchQueue.main.async {
      os_log("Compass: clearMap called.")
      compass?.clearMap(configuration: config)
    }
  }
  
  @objc(centerAndZoom:zoomLevel:)
  func centerAndZoom(asset: String, zoomLevel: Int) -> Void {}
  
  @objc(updateEvent:eventValue:metadata:resolve:reject:)
  func updateEvent(eventType: String,
                   eventValue: String,
                   metadata: [String: Any],
                   resolve: @escaping RCTPromiseResolveBlock,
                   reject: @escaping RCTPromiseRejectBlock) -> Void {
    DispatchQueue.main.async { [weak self] in
      os_log("Compass: updateEvent called.")
      
      guard let self = self, let compass = compass else {
        let err = NSError(domain: "Bridge file error",
                          code: -1,
                          userInfo: ["description":"rn: PresentedViewController is nil"])
        reject("\(err.code)", err.debugDescription, err)
        return
      }
      
      compass.isFinishedInitialize.sink { [weak self] isFinishedInitialize in
        guard let self,
              self.checkCompassInitialization(isFinishedInitialize, reject: reject) else {
          return
        }
        
        let compassEvent = CompassEvent(eventType: eventType, eventValue: eventValue, eventMetadata: [:])
        compass.updateEvent(compassEvent: compassEvent)
      }
      .store(in: &self.cancellables)
      
      var isCancelled = false
      var updateStatus = true
      
      //Observe error and progress update
      self.bootstrapEventEmitterHandler = { [weak self] eventEmitterDescription in
        guard let self else { return }
        
        os_log("Compass: compassAddEvent %{public}@ %{public}@",
               log: self.log,
               eventEmitterDescription.description,
               eventEmitterDescription.eventType.rawValue)
        isCancelled = true
        if updateStatus {
          updateStatus = false
          resolve(eventEmitterDescription.description)
        }
      }
      
      guard !isCancelled else {
        return
      }
      self.errorEventEmitterHandler = { [weak self] errorEventEmitter in
        guard let self else { return }
        
        var event = [String : Any]()
        event["code"] = errorEventEmitter.errorCode
        event["errortype"] = errorEventEmitter.compassErrorType
        event["message"] = errorEventEmitter.errorDescription
        os_log("Compass: displayPins error %{public}@ %{public}@",
               log: self.log,
               event,
               errorEventEmitter.eventType.rawValue)
        
        self.sendEvent(withName: Event.compassErrorEvent.rawValue, body: event)
        
        if updateStatus {
          updateStatus = false
          reject("-1", "Compass updateEvent failed", nil)
        }
      }
    }
  }
  
  @objc(displayMap:workflowId:workflowValue:resolve:reject:)
  func displayMap(workflowType: String,
                  workflowId: String,
                  workflowValue: String,
                  resolve: @escaping RCTPromiseResolveBlock,
                  reject: @escaping RCTPromiseRejectBlock) -> Void {
    DispatchQueue.main.async { [weak self] in
      guard let self = self, let compass = compass else {
        let err = NSError(domain: "Bridge file error",
                          code: -1,
                          userInfo: ["description":"rn: PresentedViewController is nil"])
        reject("\(err.code)", err.debugDescription, err)
        return
      }
      
      let workflow = Workflow(id: workflowId, type: workflowType, value: workflowValue)
      var didResolve = false
      let resolveOnce: (String) -> Void = { message in
        guard !didResolve else { return }
        didResolve = true
        resolve(message)
      }

      compass.displayMap(workflow: workflow)

      compass.isFinishedSettingMap
        .removeDuplicates()
        .filter { $0 }
        .prefix(1)
        .sink { [weak self] _ in
          guard let self else { return }
          os_log("Compass: isFinishedSettingMap true - map ready.", log: self.log)
          compass.getStatusService().emitMapStatusEvent(isSuccess: true)
          resolveOnce("Compass map display completed")
        }
        .store(in: &self.cancellables)
      
      //Observe error and progress update
      self.showMapEventEmitterHandler = { [weak self] eventEmitterDescription in
        guard let self else { return }
        
        os_log("Compass: compassDisplayMapEvent %{public}@ %{public}@",
               log: self.log,
               eventEmitterDescription.description,
               eventEmitterDescription.eventType.rawValue)
        resolveOnce(eventEmitterDescription.description)
      }
    }
  }

    @objc(updateAuthParams:consumerID:accountID:)
    func updateAuthParams(clientSec: String, consumerID: String, accountID: String) -> Void {}
    
    // MARK: - Helper methods
    func send(_ event: Event, dict: Any) {
      self.sendEvent(withName: event.rawValue, body: dict)
    }
  }
  
  private extension CompassSdkRn {
    func checkCompassInitialization(_ isFinishedInitialize: Bool?, reject: @escaping RCTPromiseRejectBlock) -> Bool {
      guard let isFinishedInitialize else {
        os_log("Compass: Compass waiting initialization", log: self.log)
        return false
      }
      
      guard isFinishedInitialize else {
        Log.debug("Compass: Compass Initialization Failed")
        let err = NSError(
          domain: "Unknown error",
          code: -1,
          userInfo: ["description": "Compass initialization failed. Please ensure that the comoass has been correctly set up and configured."]
        )
        reject("\(err.code)", err.debugDescription, err)
        return false
        
      }
      
      return true
    }
}
