import Combine
import CoreData
import Foundation
import UIKit

import IPSFramework

protocol CompassViewModelType {
    var rootViewController: UIViewController? { get set }
    var isFinishedInitializePublisher: CurrentValueSubject<Bool?, Never> { get }
    var isFinishedSettingMapPublisher: CurrentValueSubject<Bool, Never> { get }
    var isBlueDotEnabledPublisher: CurrentValueSubject<Bool?, Never> { get }
    var currentStore: Int? { get }
    var canCompleteInitialization: (() -> Bool)? { get set }

    func initialize(authParameter: AuthParameter,
                    configuration: Configuration,
                    capabilities: [CompassCapability],
                    customMapRequest: URLRequest?)
    func getAccessToken(authParameter: AuthParameter) -> AnyPublisher<AccessTokenResponse?, Never>
    func toggleMockUser(_ option: Bool)
    func updateStoreConfiguration(_ storeConfig: StoreConfig?)
    func getAisle(id: String)
    func isMapViewReady() -> AnyPublisher<Bool, Never>
    func displayMap()
    func clearMap(mapConfig: MapConfig)
    func updateEvent(compassEvent: CompassEvent)
    func updateEventList(namespace: String, eventType: String, eventValue: String, metaData: HashMap?)
    func displayPin(uuidList: [String], idType: PinDropMethod, config: DisplayPinConfig?)
    func displayPin(pins: [CompassPin]?, config: DisplayPinConfig?, isZoomOutRequired: Bool)
    func displayStaticPath(pins: [CompassPin], startFromNearbyEntrance: Bool, disableZoomGestures: Bool)
    func startPositionSession()
    func stopPositioning()
    func resetPositionStatusEvent()
    func killSwitch()
    func removeUserPositionIndicator()
    func getUserDistance(pins: [AislePin], completion: UserDistanceCompleteHandler?)
}

final class CompassViewModel: CompassViewModelType {
    internal var mapHostViewModel: MapHostViewModelType?
    internal var isPositioningEnabled: Bool = false
    private var capabilities: [CompassCapability] = []
    private var includeLocationInHeatbeat: Bool = false
    private var includeUserInHeatbeat: Bool = false
    private var positioningSessioinTimeout: Int = 2
    internal var positionSessionTimer: Timer?
    internal var positionRefreshTime: Double = 1.0
    internal var sessionRefreshTime: Int = SessionTime.positionRefreshTime
    internal var assetService: AssetService
    let serviceLocator: ServiceLocatorType
    private var cancellable: Set<AnyCancellable> = []
    private var shouldClearBlueDot: Bool = false
    private let defaultsStore: UserDefaultsStore
    private let finishedInitializeSubject = CurrentValueSubject<Bool?, Never>(nil)
    private let finishedSettingMapSubject = CurrentValueSubject<Bool, Never>(false)
    private let blueDotEnabledSubject = CurrentValueSubject<Bool?, Never>(nil)
    private(set) var currentStore: Int?
    var canCompleteInitialization: (() -> Bool)?

    var isFinishedInitializePublisher: CurrentValueSubject<Bool?, Never> {
        finishedInitializeSubject
    }

    var isFinishedSettingMapPublisher: CurrentValueSubject<Bool, Never> {
        finishedSettingMapSubject
    }

    var isBlueDotEnabledPublisher: CurrentValueSubject<Bool?, Never> {
        blueDotEnabledSubject
    }

    weak var rootViewController: UIViewController?

    init(serviceLocator: ServiceLocatorType, defaultsStore: UserDefaultsStore = UserDefaultsStore()) {
        self.serviceLocator = serviceLocator
        self.assetService = serviceLocator.getAssetService()
        self.defaultsStore = defaultsStore
        Analytics.logDefault = serviceLocator.getLogDefaultImpl()
        bindAppLifecycleObservation()
    }

    func initialize(authParameter: AuthParameter,
                    configuration: Configuration,
                    capabilities: [CompassCapability],
                    customMapRequest: URLRequest?) {
        cancellable.removeAll()
        var mutableAuthParameter = authParameter
        mutableAuthParameter.tokenType = mutableAuthParameter.tokenType.lowercased()
        currentStore = configuration.site
        self.capabilities = capabilities
        APIPath.customStoreMapRequest = customMapRequest
        Analytics.initialization(state: .start)
        Analytics.anonymizedUserID = configuration.anonymizedUserID
        toggleMockUser(configuration.mockUser)
        Log.info("""
                Start initialize API with authParameter: \(mutableAuthParameter)
                configuration: \(configuration)
                rootViewController: \(String(describing: rootViewController))
                compassVersion: \(DeviceInformation.getCompassSDKVersion())
                oriientVersion: \(DeviceInformation.getOriientSDKVersion())
                """)
        beginInitialization(authParameter: mutableAuthParameter, configuration: configuration)
    }

    /// Initialize the CompassViewModel class.
    /// This is use to assign accessTokenService and configurationService.

    /// This is used to retrieve access token based on clientId and consumerId.
    /// Will also store access token data in core data model .
    func getAccessToken(authParameter: AuthParameter) -> AnyPublisher<AccessTokenResponse?, Never> {
        return Just(authParameter.authToken.isEmptyOrWhitespace() ? nil : authParameter)
            .flatMap { [weak self] authParameter -> AnyPublisher<AccessTokenResponse?, Never> in
                guard let self = self, let authParameter else {
                    self?.logAndHandleEmptyAuthParameter()
                    return Just(nil).eraseToAnyPublisher()
                }
                return self.handleTokenType(for: authParameter)
            }
            .eraseToAnyPublisher()
    }

    func toggleMockUser(_ option: Bool) {
        Log.info("Set up Mock User: \(option)")
        if option {
            IPSPositioning.testLockThreshold = 0
        }
    }

    func updateStoreConfiguration(_ storeConfig: StoreConfig?) {
        #if DEBUG
        if let assetService = serviceLocator.getAssetService() as? AssetServiceImpl {
            assetService.lastStoreConfig = storeConfig
        }
        #endif
        positionRefreshTime = storeConfig?.positioningSessionTimeout ?? 1
        sessionRefreshTime = storeConfig?.sessionRefreshTime ?? sessionRefreshTime
        setStore(using: storeConfig)
        setSupportedEventList(using: storeConfig)
        setMapType(using: storeConfig)
        setStoreConfigOffset(using: storeConfig)
        setupLogIntervalsData(storeConfig: storeConfig)
        defaultsStore.saveSessionId()
    }

    func getAisle(id: String) {
        mapHostViewModel?.getAisle(id: id)
    }

    func isMapViewReady() -> AnyPublisher<Bool, Never> {
        serviceLocator.getMapFocusManager().isMapViewPresent.eraseToAnyPublisher()
    }

    func displayMap() {
        Log.debug("API Called: displayMap")
        Analytics.telemetry(payload: TelemetryAnalytics(event: DisplayMap.DISPLAY_MAP_REQUESTED.rawValue))
        startPositionSession()
        mapHostViewModel?.displayMap()
    }

    func clearMap(mapConfig: MapConfig) {
        Log.debug("API Called: clearMap with config: \(mapConfig)")
        mapHostViewModel?.clearMap(mapConfig: mapConfig)
    }

    func updateEvent(compassEvent: CompassEvent) {
        Log.debug("API Called: updateEvent for event: \(compassEvent)")

        startPositionSession()

        guard let position = serviceLocator.getIndoorPositioningService().lastLockedPosition else {
            Log.info("The value of lastLockedPosition is nil")
            emitUpdateEventError()
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: UpdateEvent.UPDATE_EVENT_ERROR_NOT_LOCKED.rawValue
            ))
            return
        }

        guard let converter = serviceLocator.getIndoorPositioningService().floorCoordinatesConverter else {
            Log.info("The value of floorCoordinatesConverter is nil")
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: UpdateEvent.UPDATE_EVENT_ERROR_NOT_LOCKED.rawValue
            ))
            emitUpdateEventError()
            return
        }

        serviceLocator.getEventService()
            .cacheAndBootstrapAsset(
                compassEvent, position: position.convertToCompass(using: converter).asCGPoint()
            ) { [ weak self] bootstrapStatus in
                if bootstrapStatus == .notBootstrapped {
                    self?.emitUpdateEventError()
                    Analytics.telemetry(payload: TelemetryAnalytics(
                        isError: true,
                        event: UpdateEvent.UPDATE_EVENT_ERROR_QUADTREE_CALC.rawValue
                    ))
                }
            }
    }

    func updateEventList(namespace: String, eventType: String, eventValue: String, metaData: HashMap?) {
        guard isPositioningEnabled else {
            Log.info("Blue dot is disabled")
            return
        }

        startPositionSession()
        let supportedEventList = assetService.supportedEventList.components(
            separatedBy: "},"
        )
        let eventKey = "\(namespace)/\(eventType)"
        let isSupportedEvent = supportedEventList.filter {
            $0.lowercased().contains(eventKey.lowercased()) &&
            ($0.lowercased().contains("\"enabled\": true") || $0.lowercased().contains("\"enabled\":true"))
        }

        guard !isSupportedEvent.isEmpty else {
            Log.info("The event list is not supported.")
            emitUpdateEventListError()
            Analytics.telemetry(payload: TelemetryAnalytics(
                isError: true,
                event: UpdateEvent.UPDATE_EVENT_ERROR_INVALID_INPUT.rawValue
            ))
            return
        }

        let position = serviceLocator.getIndoorPositioningService().lastLockedPosition
        let converter = serviceLocator.getIndoorPositioningService().floorCoordinatesConverter

        let compassPosition: CGPoint?
        if let converter {
            compassPosition = position?.convertToCompass(using: converter).asCGPoint()
        } else {
            compassPosition = nil
        }

        let eventAnalytics: EventAnalytics.EventLocation?
        if let compassPosition {
            eventAnalytics = EventAnalytics.EventLocation(
                roc: EventAnalytics.EventLocationRoc(x: compassPosition.x, y: compassPosition.y)
            )
        } else {
            eventAnalytics = nil
        }

        let event = EventAnalytics.Event(
            id: RequestIdentifier.id1.rawValue,
            type: eventType,
            value: eventValue,
            properties: metaData?.toCodableValueDictionary()
        )

        Log.info("""
                 [COVERAGE] updateEventList block executed for namespace: \(namespace),
                 eventType: \(eventType), eventValue: \(eventValue)
            """)
        let payload = EventAnalytics(namespace: namespace,
                                     location: eventAnalytics,
                                     event: event,
                                     isPositionLocked: position?.isLocked ?? false)

        Analytics.updateEvent(payload: payload)
        Log.info("Update Event List: \(payload)")
        self.serviceLocator.getStatusService().emitUpdateEventList(description: "Compass UpdateEventList success")
    }

    func resetPositionStatusEvent() {
        self.serviceLocator.getStatusService().resetCompassPositionType()

        guard !isPositioningEnabled else { return }
        self.serviceLocator.getStatusService().emitPositionStatusEvent(
            calibrationProgress: 0,
            isCalibrationGestureNeeded: false,
            positioningProgress: 0,
            isPositionLocked: true
        )
    }

    func displayPin(uuidList: [String], idType: PinDropMethod, config: DisplayPinConfig?) {
        Log.debug("displayPin called: \(uuidList), idType:\(idType.rawValue), config: \(String(describing: config))")
        startPositionSession()
        mapHostViewModel?.displayPin(uuidList: uuidList, idType: idType, config: config)
    }

    func displayPin(pins: [CompassPin]?, config: DisplayPinConfig?, isZoomOutRequired: Bool) {
        startPositionSession()
        mapHostViewModel?.displayPin(pins: pins, config: config, isZoomOutRequired: isZoomOutRequired)
    }

    func displayStaticPath(pins: [CompassPin], startFromNearbyEntrance: Bool, disableZoomGestures: Bool) {
        Log.debug(
            """
            API Called: displayStaticPath for: \(pins),
            startFromNearbyEntrance:\(startFromNearbyEntrance),
            disableZoomGestures: \(disableZoomGestures)
            """
        )
        startPositionSession()
        mapHostViewModel?.displayStaticPath(pins: pins,
                                            startFromNearbyEntrance: startFromNearbyEntrance,
                                            disableZoomGestures: disableZoomGestures)
    }

    // If multiple getUserDistance calls are made in quick succession (example: by different UI actions or async flows)
    // the requestId helps us match each response to its original request.
    func getUserDistance(pins: [AislePin], completion: UserDistanceCompleteHandler?) {
        Log.debug("API Called: getUserDistance for pins: \(pins)")
        startPositionSession()
        mapHostViewModel?.getUserDistance(pins: pins, completion: completion)
    }

    func killSwitch() {
        stopPositioning()
        serviceLocator.getUserPositionManager().logout()
        cancellable.removeAll()
    }

    func removeUserPositionIndicator() {
        guard let mapHostViewModel = mapHostViewModel else {
            Log.warning("Cannot remove user position indicator: mapHostViewModel is nil")
            return
        }
        mapHostViewModel.removeUserPositionIndicator()
    }

    deinit {
        positionSessionTimer?.invalidate()
        positionSessionTimer = nil
        Log.info("Released CompassViewModel")
    }
}

private extension CompassViewModel {
    func beginInitialization(authParameter: AuthParameter, configuration: Configuration) {
        guard validateConfiguration(configuration) else { return }

        getAccessToken(authParameter: authParameter)
            .flatMap { [weak self] accessTokenResponse -> AnyPublisher<StoreConfig?, Never> in
                guard let self else { return Empty().eraseToAnyPublisher() }
                Log.info("AccessTokenResponse: \(String(describing: accessTokenResponse))")
                if accessTokenResponse == nil {
                    Analytics.telemetry(
                        payload: TelemetryAnalytics(
                            isError: true,
                            event: CommonErrors.ERROR_INVALID_AUTH.rawValue,
                            context: CommonErrors.ErrorContext.CONTEXT_INIT.rawValue
                        )
                    )
                }
                return self.fetchConfigurationDetails(configuration: configuration)
            }
            .filter { [weak self] config in
                self?.validateAndUpdateStoreConfig(config) ?? false
            }
            .flatMap { [weak self] _ -> AnyPublisher<Bool, Never> in
                guard let self else { return Empty().eraseToAnyPublisher() }
                if self.capabilities.contains(.storeMap) {
                    Log.info("Deleting EventStoreService Event")
                    return self.deleteAllEvents()
                        .flatMap { [weak self] _ -> AnyPublisher<Bool, Never> in
                            guard let self else { return Empty().eraseToAnyPublisher() }
                            return self.completeInitialization()
                        }
                        .eraseToAnyPublisher()
                }

                if self.capabilities.contains(.productEnrollment) {
                    self.serviceLocator.getImageUploader().startUploads()
                    self.finishedInitializeSubject.send(true)
                }

                return Just(true).eraseToAnyPublisher()
            }
            .sink { [weak self] isFinishedInitialize in
                guard let self else { return }
                guard isFinishedInitialize else {
                    return
                }

                Log.info("Finished fetching map. Map is ready to load.")
                self.finishedSettingMapSubject.send(true)
            }
            .store(in: &cancellable)
    }

    func validateConfiguration(_ configuration: Configuration) -> Bool {
        guard configuration.site != 0 else {
            Log.warning("Configuration is not valid")
            Analytics.telemetry(
                payload: TelemetryAnalytics(
                    isError: true,
                    event: CommonErrors.ERROR_CONFIG_NOT_INITIALIZED.rawValue,
                    context: CommonErrors.ErrorContext.CONTEXT_INIT.rawValue
                )
            )
            finishedInitializeSubject.send(false)
            return false
        }
        return true
    }

    func fetchConfigurationDetails(configuration: Configuration) -> AnyPublisher<StoreConfig?, Never> {
        return fetchConfiguration(for: String(configuration.site))
            .flatMap { [weak self] configResponse -> AnyPublisher<StoreConfig?, Never> in
                guard let self else {
                    Analytics.telemetry(payload: TelemetryAnalytics(
                        isError: true,
                        event: Init.INIT_ERROR_CONFIG_AUTH.rawValue
                    ))
                    return Empty(completeImmediately: true).eraseToAnyPublisher()
                }
                Analytics.telemetry(payload: TelemetryAnalytics(event: Init.INIT_CONFIG_FETCHED.rawValue))
                return self.saveConfiguration(configuration)
                    .flatMap { _ in
                        Just(configResponse?.storeConfig).eraseToAnyPublisher()
                    }.eraseToAnyPublisher()
            }.eraseToAnyPublisher()
    }

    func validateAndUpdateStoreConfig(_ storeConfig: StoreConfig?) -> Bool {
        guard let storeConfig, let valid = storeConfig.valid, valid else {
            Log.warning("Payload storeConfig is not valid")
            Analytics.telemetry(
                payload: TelemetryAnalytics(
                    isError: true,
                    event: CommonErrors.ERROR_NOT_INITIALIZED.rawValue,
                    context: CommonErrors.ErrorContext.CONTEXT_INIT.rawValue
                )
            )
            finishedInitializeSubject.send(false)
            return false
        }

        Log.info("StoreConfig: \(storeConfig)")
        blueDotEnabledSubject.send(storeConfig.bluedotEnabled)
        updateStoreConfiguration(storeConfig)
        return true
    }

    func completeInitialization() -> AnyPublisher<Bool, Never> {
        if let canCompleteInitialization, canCompleteInitialization() == false {
            return Empty().eraseToAnyPublisher()
        }

        Log.info("Finished initializing API, now  fetching map.")
        Analytics.initialization(state: .finish)
        finishedInitializeSubject.send(true)
        return isMapViewReady()
    }

    func fetchConfiguration(for storeId: String) -> AnyPublisher<ConfigurationPayload?, Never> {
        serviceLocator.getConfigurationService()
            .getConfigData(for: storeId)
            .retry()
            .catch { [weak self] error -> AnyPublisher<ConfigurationPayload?, Error> in
                Log.error(error)
                guard let error = error as? ErrorResponse else {
                    return Fail(error: error).eraseToAnyPublisher()
                }

                self?.serviceLocator.getStatusService()
                    .emitErrorStatusEvent(for: error, isInitError: true)
                return Fail(error: error).eraseToAnyPublisher()
            }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    func saveConfiguration(_ configuration: Configuration) -> AnyPublisher<Configuration, Never> {
        serviceLocator.getConfigurationStoreService().setConfiguration(configuration)
        return Just(configuration).eraseToAnyPublisher()
    }

    func deleteAllEvents() -> AnyPublisher<Void, Never> {
        serviceLocator.getEventStoreService().deleteAllEvents()
            .retry()
            .catch { error -> AnyPublisher<Void, Error> in
                Log.error("Fail to delete EventStoreService Event from Core Database \(error.localizedDescription)")
                return Just.void()
            }
            .replaceError(with: ())
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
}
