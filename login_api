import Combine
import Foundation

import IPSFramework

enum BootstrapStatus {
    case bootstrapped
    case notBootstrapped
}

protocol EventService {
    func cacheEvent(_ event: CompassEvent,
                    position: CGPoint,
                    aisle: String,
                    allAisles: [String]?)
    func cacheAndBootstrapAsset(_ event: CompassEvent,
                                position: CGPoint) async -> BootstrapStatus
}

class EventServiceImpl: EventService {
    var cancellables = Set<AnyCancellable>()
    let configurationService: ConfigurationService
    let statusService: StatusService
    private let eventStoreService: EventStoreService
    private let networkService: NetworkServiceType
    private let defaultsStore: UserDefaultsStore

    init(serviceLocator: ServiceLocatorType, defaultsStore: UserDefaultsStore = UserDefaultsStore()) {
        self.configurationService = serviceLocator.getConfigurationService()
        self.statusService = serviceLocator.getStatusService()
        self.eventStoreService = serviceLocator.getEventStoreService()
        self.networkService = serviceLocator.getNetworkService()
        self.defaultsStore = defaultsStore
    }

    func cacheAndBootstrapAsset(_ event: CompassEvent,
                                position: CGPoint) async -> BootstrapStatus {
        Log.info("Set up InStore Map Event \(event), position: \(String(describing: position))")
        let pinCreateResponse = await bootstrapAsset(event, position: position)
        guard pinCreateResponse?.status?.lowercased() == "ok" else {
            Log.warning("PinCreateResponse status is not ok")
            return .notBootstrapped
        }
        Log.info("PinCreateResponse: \(String(describing: pinCreateResponse))")

        let aisle = pinCreateResponse?.payload?.locationList?.first ?? LocationIdentifier.notset.rawValue

        cacheEvent(
            event,
            position: position,
            aisle: aisle,
            allAisles: pinCreateResponse?.payload?.locationList
        )
        return .bootstrapped
    }

    func cacheEvent(_ event: CompassEvent,
                    position: CGPoint,
                    aisle: String,
                    allAisles: [String]?) {
        let eventStoreModel = EventStoreModel(eventType: event.eventType,
                                              eventValue: event.eventValue,
                                              x: Double(position.x),
                                              y: Double(position.y),
                                              aisleLocation: aisle,
                                              aisleLocations: allAisles)
        self.saveEvent(eventStoreModel)
            .sink { [weak self] _ in
                Log.info("Finish saving InStore Map Event Cache")
                self?.statusService.emitBootstrapEvent(description: "Compass UpdateEvent success")
            }
            .store(in: &cancellables)
    }
}

private extension EventServiceImpl {
    func saveEvent(_ eventStoreModel: EventStoreModel) -> AnyPublisher<EventStoreModel, Never> {
        eventStoreService.insertOrUpdateEvent(eventStoreModel)
            .retry()
            .catch { error -> AnyPublisher<EventStoreModel, Never> in
                Log.error(error)
                return Empty().eraseToAnyPublisher()
            }
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    func addEventPublisher(_ event: CompassEvent, position: CGPoint) -> AnyPublisher<PinCreateResponse?, Error>? {
        let sessionId = defaultsStore.sessionId
        guard let configuration = configurationService.getStoreConfiguration(), sessionId != "" else {
            Log.warning("Request add event failed.")
            return nil
        }
        return self.networkService.addEvent(event,
                                            position: position,
                                            storeId: configuration.site,
                                            userId: configuration.userId,
                                            sessionId: sessionId)
            .eraseToAnyPublisher()
    }

    func bootstrapAsset(_ event: CompassEvent, position: CGPoint) async -> PinCreateResponse? {
        Log.info("Request bootstrap asset using event: \(event), location: \(String(describing: position))")
        guard let publisher = addEventPublisher(event, position: position) else {
            return nil
        }

        do {
            return try await awaitPublisher(publisher.retry())
        } catch {
            guard let error = error as? ErrorResponse else {
                Log.error(error)
                return nil
            }
            statusService.emitErrorStatusEvent(for: error, isInitError: false)
            return nil
        }
    }

    func awaitPublisher<T>(_ publisher: AnyPublisher<T, Error>) async throws -> T {
        try await withCheckedThrowingContinuation { continuation in
            var didResume = false
            var cancellable: AnyCancellable?
            cancellable = publisher.sink { completion in
                guard !didResume else { return }
                didResume = true
                if case let .failure(error) = completion {
                    continuation.resume(throwing: error)
                } else {
                    let error = NSError(
                        domain: "EventService",
                        code: -1,
                        userInfo: [NSLocalizedDescriptionKey: "Unknown error"]
                    )
                    continuation.resume(throwing: error)
                }
                cancellable?.cancel()
                cancellable = nil
            } receiveValue: { value in
                guard !didResume else { return }
                didResume = true
                continuation.resume(returning: value)
                cancellable?.cancel()
                cancellable = nil
            }
        }
    }
}
