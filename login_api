import Combine
import IPSFramework

typealias AssetFetchBlock = ([CGPoint]) -> Void

protocol AssetService {
    var supportedEventList: String { get set }
    var storeId: Int { get set }
    var mapType: MapIdentifier { get set }
    var storeConfigOffset: StoreConfigOffset { get set }
    var idList: [String] { get set }
    var idType: PinDropMethod { get set }
    var assetEvents: [String: AssetEvent] { get set }

    func evaluateAssets(using idList: [String],
                        idType: PinDropMethod,
                        pinDropType: PinDropType,
                        onCompletion: @escaping AssetFetchBlock)

    func evaluateAisles(using id: String,
                        pinDropType: PinDropType,
                        position: CGPoint,
                        onCompletion: @escaping AssetFetchBlock)

    func fetchFeatureLocations(
        forAisleIds aisleIds: [String]
    ) async -> [(CGPoint, String)]
}

final class AssetServiceImpl: AssetService {
    var cancellable = Set<AnyCancellable>()
    private var featureLocationTask: Task<[(CGPoint, String)], Never>?
    private var featureLocationRequestId = 0
    let statusService: StatusService
    let eventStoreService: EventStoreService
    let indoorPositioningService: IndoorPositioningService
    let eventService: EventService
    let networkService: NetworkServiceType

    var storeId = 0
    var mapType = MapIdentifier.WalmartMap
    var storeConfigOffset = StoreConfigOffset(x: 4620.0, y: 3430.0)
    var idList = [String]()
    var idType: PinDropMethod = .assets
    var assetEvents = [String: AssetEvent]()
    var supportedEventList: String = ""

    init(serviceLocator: ServiceLocatorType) {
        self.statusService = serviceLocator.getStatusService()
        self.eventStoreService = serviceLocator.getEventStoreService()
        self.indoorPositioningService = serviceLocator.getIndoorPositioningService()
        self.eventService = serviceLocator.getEventService()
        self.networkService = serviceLocator.getNetworkService()
    }

    func evaluateAssets(using idList: [String],
                        idType: PinDropMethod,
                        pinDropType: PinDropType,
                        onCompletion: @escaping  AssetFetchBlock) {
        Log.info("Evaluate assets for \(mapType.rawValue) map.")
        self.idList = idList
        self.idType = idType
        assetEvents.removeAll()
        Publishers.Sequence(sequence: idList).eraseToAnyPublisher()
            .flatMap { [weak self] assetId -> AnyPublisher<[AssetPayload], Never> in
                guard let self else { return Empty(completeImmediately: true).eraseToAnyPublisher() }
                switch idType {
                case .assets:
                    return getCachedAssetOrFetch(assetId: assetId)
                case .generic:
                    return decodeGeneric(encodedString: assetId)
                }
            }
            .sink { [weak self] assetPayloads in
                guard let self else { return }
                assetPayloads.forEach { payload in
                    Log.info("AssetPayload: \(String(describing: payload))")
                    self.emitPinEvent(assetId: payload.id,
                                      position: payload.cgPoint,
                                      pinDropType: pinDropType,
                                      assetPayload: payload,
                                      onCompletion: onCompletion)

                    let pinLocation = "\(payload.x), \(payload.y)"
                    Analytics.displayPin(payload: DisplayPinAnalytics(pinType: self.idType.analyticsStringValue,
                                                                      pinValue: payload.id,
                                                                      pinCategory: "auto",
                                                                      pinLocation: pinLocation,
                                                                      success: true))
                }
            }
            .store(in: &cancellable)
    }

    func evaluateAisles(using id: String,
                        pinDropType: PinDropType,
                        position: CGPoint,
                        onCompletion: @escaping AssetFetchBlock) {
        switch idType {
        case .assets:
            fetchAisleInfo(for: id, position: position)
                .sink { [weak self] assetPayload in
                    Log.info("Handle \(self?.mapType.rawValue ?? "unknown map") asset")
                    self?.emitPinEvent(assetId: id,
                                       position: assetPayload.cgPoint,
                                       pinDropType: pinDropType,
                                       assetPayload: assetPayload,
                                       onCompletion: onCompletion)
                }
                .store(in: &cancellable)
        case .generic:
            // Retrieve aisle location from network call. If the network call fails or returns an error,
            // return the default payload value using replaceEmpty
            // Note: Backend is not ready to handle cases where asset Id is nil.
            fetchAisleInfo(for: id, position: position)
                .replaceEmpty(with: useDefaultAssetPayload(id: id,
                                                           coordinate: Coordinate(
                                                            x: position.x,
                                                            y: position.y
                                                           )
                                                          ))
                .sink { [weak self] assetPayload in
                    Log.info("Handle \(self?.mapType.rawValue ?? "unknown map") non asset")
                    self?.emitPinEvent(assetId: id,
                                       position: assetPayload.cgPoint,
                                       pinDropType: pinDropType,
                                       assetPayload: assetPayload,
                                       onCompletion: onCompletion)
                }
                .store(in: &cancellable)
        }
    }

    func fetchFeatureLocations(
        forAisleIds aisleIds: [String]
    ) async -> [(CGPoint, String)] {
        featureLocationRequestId += 1
        let requestId = featureLocationRequestId

        featureLocationTask?.cancel()
        let task = Task { [weak self] () -> [(CGPoint, String)] in
            guard let self else { return [] }
            return await self.fetchFeatureLocationsInternal(forAisleIds: aisleIds)
        }
        featureLocationTask = task

        let result = await task.value
        guard requestId == featureLocationRequestId else { return [] }
        return result
    }
}

private extension AssetServiceImpl {
    func fetchFeatureLocationsInternal(
        forAisleIds aisleIds: [String]
    ) async -> [(CGPoint, String)] {
        do {
            let response = try await awaitPublisher(
                networkService.getFeatureLocation(aisleIds: aisleIds, storeId: storeId).retry()
            )
            return (response?.payload ?? [])
                .compactMap { item in
                    guard !item.roc.x.isNaN, !item.roc.y.isNaN, !item.id.isEmpty else { return nil }
                    return (item.roc.toCGPoint(), item.id)
                }
        } catch is CancellationError {
            return []
        } catch {
            Log.error(error)
            if let error = error as? ErrorResponse {
                statusService.emitErrorStatusEvent(for: error, isInitError: false)
            }
            return []
        }
    }

    func awaitPublisher<P: Publisher>(_ publisher: P) async throws -> P.Output where P.Failure == Error {
        let stream = AsyncThrowingStream<P.Output, Error> { continuation in
            let cancellable = publisher.sink { completion in
                switch completion {
                case .failure(let error):
                    continuation.finish(throwing: error)
                case .finished:
                    continuation.finish()
                }
            } receiveValue: { value in
                continuation.yield(value)
            }
            continuation.onTermination = { _ in
                cancellable.cancel()
            }
        }

        for try await value in stream {
            return value
        }
        throw CancellationError()
    }

    func decodeGeneric(encodedString: String) -> AnyPublisher<[AssetPayload], Never> {
        guard let location = LocationConverter.decodeMessage(outMsg: encodedString), location.store == storeId else {
            return Empty(completeImmediately: true).eraseToAnyPublisher()
        }

        return Publishers.MergeMany(location.coordinates.map {
            // Note: Backend is not ready to handle cases where asset Id is nil.
            fetchAisleInfo(for: encodedString, position: CGPoint(x: $0.x, y: $0.y))
                .replaceEmpty(with: useDefaultAssetPayload(id: encodedString, coordinate: $0))
        })
        .collect()
        .eraseToAnyPublisher()
    }

    func useDefaultAssetPayload(id: String, coordinate: Coordinate) -> AssetPayload {
        Log.info("Replacing empty value with default asset payload as the backend API response was empty.")
        return AssetPayload(id: id,
                            x: coordinate.x,
                            y: coordinate.y,
                            z: coordinate.z,
                            type: idType.rawValue,
                            aisle: LocationIdentifier.unknown.rawValue,
                            allAisles: [LocationIdentifier.unknown.rawValue])
    }

    func emitPinEvent(assetId: String,
                      position: CGPoint,
                      pinDropType: PinDropType,
                      assetPayload: AssetPayload,
                      onCompletion: AssetFetchBlock) {
        Log.info("""
                 Set Assets Status Event assetId: \(assetId) pinDropType: \(pinDropType)
                 mapType:\(self.mapType.rawValue) assetLocations:\(String(describing: assetPayload.allAisles))
                 """)

        switch pinDropType {
        case .pinAisleLoc:
            statusService.emitLocationEvent(assetLocation: assetPayload.aisle)
        case .autoPinDropAisleLocList, .manualPinDropAisleLocList:
            var position = position
            if mapType == .OriientMap {
                guard let converter = indoorPositioningService.floorCoordinatesConverter else {
                    return
                }
                position = position.convertToOriient(using: converter).asCGPoint()
            }
            onCompletion([position])
            let assetEvent = AssetEvent(assetId: assetId,
                                        locations: assetPayload.allAisles ?? [],
                                        coordinate: position.asCompassCoordinate(),
                                        success: true)
            assetEvents[assetId] = assetEvent
            guard !idList.isEmpty, idList.count == assetEvents.count else {
                return
            }
            Log.info("""
            Set Assets Status Event - assetId: \(assetId) pinDropType: \(pinDropType) mapType:\(mapType)
            assetEvents:\(String(describing: assetEvents))
            """)
            statusService.emitPinDropEvent(using: assetId,
                                           storeId: storeId,
                                           pinDropType: pinDropType,
                                           mapType: mapType.rawValue,
                                           assetEvents: assetEvents,
                                           idType: idType)
            idList.removeAll()
            assetEvents.removeAll()
        }
    }

    func getCachedAssetOrFetch(assetId: String) -> AnyPublisher<[AssetPayload], Never> {
        Log.info("Get StoreMap asset for assetId \(assetId)")
        return self.getCachedEvent(using: assetId)
            .flatMap { [weak self] eventStoreModel -> AnyPublisher<[AssetPayload], Never> in
                guard let self else {
                    return Empty(completeImmediately: true).eraseToAnyPublisher()
                }
                guard let model = eventStoreModel,
                      model.aisleLocation != LocationIdentifier.notset.rawValue else {
                    return self.fetchAsset(for: assetId)
                        .compactMap { $0?.payload }
                        .replaceEmpty(with: useDefaultAssetPayload(
                            id: assetId,
                            coordinate: Coordinate(x: eventStoreModel?.x ?? 0.0,
                                                   y: eventStoreModel?.y ?? 0.0)
                        ))
                        .flatMap { payload -> AnyPublisher<[AssetPayload], Never> in
                            let compassEvent = CompassEvent(eventType: EventConstant.Category.assetScan.rawValue,
                                                            eventValue: assetId)
                            self.eventService.cacheEvent(
                                compassEvent,
                                position: payload.cgPoint,
                                aisle: payload.aisle,
                                allAisles: payload.allAisles
                            )
                            return Just([payload]).eraseToAnyPublisher()
                        }
                        .eraseToAnyPublisher()
                }
                let assetPayload = AssetPayload(id: assetId,
                                                x: model.x,
                                                y: model.y,
                                                z: 0,
                                                type: model.eventType,
                                                aisle: model.aisleLocation,
                                                allAisles: model.aisleLocations ?? ["unknown"])
                return Just([assetPayload]).eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()
    }

    func getCachedEvent(using assetId: String) -> AnyPublisher<EventStoreModel?, Never> {
        eventStoreService.getEvent(for: assetId)
            .retry()
            .catch { error -> AnyPublisher<EventStoreModel?, Error> in
                Log.error(error)
                return Fail(error: error).eraseToAnyPublisher()
            }
            .replaceError(with: nil)
            .receive(on: DispatchQueue.main)
            .eraseToAnyPublisher()
    }

    func fetchAsset(for assetId: String) -> AnyPublisher<AssetResponse?, Never> {
        networkService.getAsset(for: assetId, storeId: self.storeId)
            .retry()
            .catch { [weak self] error -> AnyPublisher<AssetResponse?, Error> in
                Log.error(error)
                Analytics.telemetry(
                    payload: TelemetryAnalytics(
                        isError: true,
                        event: self?.idType == .generic ?
                        DisplayPin.DISPLAY_PIN_ERROR_ASSET_FETCH_INVALID.rawValue :
                            DisplayPin.DISPLAY_PIN_ERROR_GENERIC_WRONG_STORE.rawValue
                    )
                )
                guard let error = error as? ErrorResponse else {
                    return Fail(error: error).eraseToAnyPublisher()
                }

                self?.statusService.emitErrorStatusEvent(for: error, isInitError: false)
                return Fail(error: error).eraseToAnyPublisher()
            }
            .replaceError(with: nil)
            .eraseToAnyPublisher()
    }

    func fetchAisleInfo(for assetId: String?, position: CGPoint) -> AnyPublisher<AssetPayload, Never> {
        networkService.getAisle(for: assetId, storeId: storeId, position: position)
            .retry()
            .catch { [weak self] error -> AnyPublisher<AssetResponse?, Error> in
                Log.error(error)
                guard let error = error as? ErrorResponse else {
                    return Fail(error: error).eraseToAnyPublisher()
                }

                self?.statusService.emitErrorStatusEvent(for: error, isInitError: false)
                return Fail(error: error).eraseToAnyPublisher()
            }
            .replaceError(with: nil)
            .compactMap { $0?.payload }
            .eraseToAnyPublisher()
    }
}

#if DEBUG
extension AssetServiceImpl {
    private enum AssociatedKeys {
        static var lastStoreConfig = "lastStoreConfig"
    }

    var lastStoreConfig: StoreConfig? {
        get {
            objc_getAssociatedObject(self, AssociatedKeys.lastStoreConfig) as? StoreConfig
        }
        set {
            objc_setAssociatedObject(self,
                                     AssociatedKeys.lastStoreConfig,
                                     newValue,
                                     .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }
}
#endif
