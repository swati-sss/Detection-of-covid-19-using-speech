import CoreGraphics
import Foundation
import Combine

enum ZoomTarget {
    case userLocation
    case pinAnnotation
}

class StoreMapLoaderViewModel {
    weak var mapViewDelegate: StoreMapsViewDelegate?
    let blueDotMode: BlueDotMode
    let userPositionManager: UserPositionManagement
    private(set) var navigationEnabled: Bool?
    private(set) var pinsConfig: PinsConfig

    var currentZoomScale: CGFloat = 0
    var lastPathfindingEnabled: Bool?
    var isStaticPathVisible = false
    var staticPathPreviewCancellable: AnyCancellable?
    var routeCancellable: AnyCancellable?
    var pinList: (current: PinList?, last: PinList?)
    var isPinDistanceFetched: Bool = false
    var pinLocationFetchCompletionHandler: PinLocationFetchCompletionHandler?
    var pinRenderCompletion: (([Pin]) -> Void)?
    var floorSelected = 0

    internal var assetService: AssetService
    internal var statusService: StatusService
    internal var indoorNavigationService: IndoorNavigationService
    internal var staticPathPreviewService: StaticPathPreviewService

    private(set) var indoorPositioningService: IndoorPositioningService
    private(set) var mapFocusManager: MapFocusManager
    private(set) var keychainService: KeychainServiceType
    private(set) var eventService: EventService
    private(set) var messageParser: MessageParsing
    private(set) var messageSender: MessageSending

    internal var mapData: MapData?
    internal var mapLoadedData: MapLoaded?
    internal var hasLoadedMapView = false
    internal var hasMapViewZoomed = false
    internal var renderedPins: [Pin] = []
    internal var renderedPinsZoomRect: CGRect?
    internal var mapDataReadyRequestTimer: Timer?

    private(set) var preferredZoomScale: CGFloat = StoreMapZoomLevel.third.minimumZoomScale
    private(set) var zoomAnalyticsLogger: ZoomAnalyticsLogger?
    private(set) var cancellable: [AnyCancellable] = []
    private(set) var callCount: Int = 0
    private(set) var lastLogTime: TimeInterval = 0

    var config = DisplayPinConfig(
        enableManualPinDrop: true,
        resetZoom: false,
        shouldZoomOnPins: true
    )

    internal var configuration = StoreMapView.Configuration(
        isPinSelectionEnabled: false,
        pin: nil,
        preferredFloor: "1"
    )

    init(blueDotMode: BlueDotMode,
         pinsConfig: PinsConfig,
         navigationConfig: NavigationConfig?,
         serviceLocator: ServiceLocatorType,
         zoomAnalyticsLogger: ZoomAnalyticsLogger? = ZoomAnalyticsLogger(workflow: Analytics.workflow)) {
        self.pinsConfig = pinsConfig
        self.blueDotMode = blueDotMode
        self.navigationEnabled = navigationConfig?.enabled ?? false
        self.messageSender = serviceLocator.getWebViewMessageSender()
        self.messageParser = serviceLocator.getWebViewMessageParser()
        self.assetService = serviceLocator.getAssetService()
        self.statusService = serviceLocator.getStatusService()
        self.indoorPositioningService = serviceLocator.getIndoorPositioningService()
        self.indoorNavigationService = serviceLocator.getIndoorNavigationService()
        self.staticPathPreviewService = serviceLocator.getStaticPathPreviewService()
        self.indoorNavigationService.navigationConfig = navigationConfig
        self.userPositionManager = serviceLocator.getUserPositionManager()
        self.mapFocusManager = serviceLocator.getMapFocusManager()
        self.eventService = serviceLocator.getEventService()
        self.keychainService = serviceLocator.getKeychainService()
        self.messageParser.delegate = self
        self.zoomAnalyticsLogger = zoomAnalyticsLogger
        self.pinList = (current: nil, last: nil)
        self.indoorNavigationService.delegate = self
    }

    deinit {
        mapDataReadyRequestTimer?.invalidate()
        mapDataReadyRequestTimer = nil
        cancellable.removeAll()
        Log.info("Released StoreMapLoaderViewModel")
    }

#if DEBUG
    func updateConfiguration(pinsConfig: PinsConfig, navigationConfig: NavigationConfig?) {
        self.pinsConfig = pinsConfig
        navigationEnabled = navigationConfig?.enabled ?? false
        indoorNavigationService.navigationConfig = navigationConfig
    }
#endif
}

extension StoreMapLoaderViewModel {
    func updateStaticPathIfNeeded(for pinRenderedMessage: PinRenderedMessage) {
        // Check if there are pins to process
        guard let pins = pinRenderedMessage.pins,
              !pins.isEmpty,
              isStaticPathVisible else {
            return
        }

        // Filter pins that are selected and valid
        let validPins = pins.filter { $0.errorData == nil }

        guard validPins == pins else {
            mapViewDelegate?.displayPinErrorBanner(true)
            setPathfindingEnabled(false, force: true)
            return
        }

        // Convert valid pins to Point list
        // Add entrance point if available
        var pointList: [Point] = []
        if staticPathPreviewService.startFromNearbyEntrance,
           let entrance = mapLoadedData?.entrances.first {
            pointList.append(Point(x: entrance.x, y: entrance.y))
        }

        // Convert valid pins to Point list and append
        pointList += validPins.compactMap { $0.location.map { Point(x: $0.x, y: $0.y) } }

        // If there are valid pins
        if !validPins.isEmpty {
            // Add route for these pins
            updateStaticPathRoute(with: pointList)
        }
    }

    // For [Pin]
    func refreshNavigationState(withPins pins: [Pin]) {
        let validPins = pins.filter { $0.errorData == nil }
        let hasPinsOnMap = !validPins.isEmpty
        indoorNavigationService.navigationSessionState?.hasPinsOnMap = hasPinsOnMap
        mapViewDelegate?.refreshNavigationButtonState(hasPinsOnMap)
    }

    // For [DrawPin]
    func refreshNavigationState(withDrawPins drawPins: [DrawPin]) {
        let validPins = drawPins.filter { $0.errorData == nil }
        let hasPinsOnMap = !validPins.isEmpty
        indoorNavigationService.navigationSessionState?.hasPinsOnMap = hasPinsOnMap
        mapViewDelegate?.refreshNavigationButtonState(hasPinsOnMap)
    }

    func renderFeatureLocationPinsIfNeeded(for pinRenderedMessage: PinRenderedMessage) {
        guard let pins = pinRenderedMessage.pins,
              !pins.isEmpty,
              pinsConfig.actionAlleyEnabled else { return }

        let errorPins = pins
            .filter(\.shouldFetchData)
            .filter { $0.errorData != nil }
        let aisleIdList = errorPins.map { "\(($0.zone ?? "").uppercased()).\($0.aisle ?? 0).\($0.section ?? 0)" }

        guard !aisleIdList.isEmpty else {
            Log.debug("No valid aisle IDs found for feature locations.")
            return
        }

        assetService.fetchFeatureLocations(forAisleIds: aisleIdList) { [weak self] results in
            guard let self = self else { return }

            let pinsToDraw = DrawPinWithZone.from(
                points: results,
                type: PinIdentifier.actionAlleyPin.rawValue,
                offset: self.assetService.storeConfigOffset
            )

            if !pinsToDraw.isEmpty {
                Log.info(
                   """
                   • Fetched feature locations for aisle IDs:
                   \(aisleIdList)
                   • Response wasp points with aisle Ids:
                   \(results)
                   • Converted store map pins:
                   \(pinsToDraw)
                   """
                )
                request(.renderActionAlleyPinRequested(PinListWithZone(pins: pinsToDraw)))
            }
        }
    }

    func updateNavigationServicesIfNeeded(for pinRenderedMessage: PinRenderedMessage) {
        // Check if there are pins to process
        guard !isStaticPathVisible,
              let pins = pinRenderedMessage.pins,
              !pins.isEmpty,
              navigationEnabled == true else {
            // Hide navigation button if no pins or disabled navigation
            mapViewDelegate?.refreshNavigationButtonState(false)
            return
        }

        // Reset navigation waypoints
        indoorNavigationService.resetWaypoints(shouldClearBlueDot: false, shouldClearPinList: true)

        // Filter pins that are selected and valid
        let validPins = pins.filter { $0.selected && $0.errorData == nil }

        // Convert valid pins to Point list
        let pointList = validPins.compactMap { $0.location.map { Point(x: $0.x, y: $0.y) } }

        // Check if there are any valid pins
        let hasValidPin = !validPins.isEmpty

        // Only update if navigation is not in progress
        let shouldUpdatePinList = indoorNavigationService.navigationSessionState?.navigationStatus != .inProgress

        // Prepare render request if needed
        let renderPinsRequest: RenderPinsRequest? = shouldUpdatePinList ? .init(
            pins: pins, pinGroupingEnabled: pinsConfig.groupPinsEnabled) : nil

        // Update navigation state with new pins
        self.indoorNavigationService.updateNavigationState(
            currentLocation: nil,
            pinWaypoint: nil,
            renderRequest: renderPinsRequest,
            pinListUpdate: nil
        )

        mapViewDelegate?.handleNavigationInterruption(for: 1, status: navigationSessionState?.navigationStatus)

        // If there are valid pins
        if hasValidPin {
            if let navigationConfig = self.indoorNavigationService.navigationConfig,
               navigationConfig.isAutomaticNavigation {
                self.indoorNavigationService.navigationSessionState?.navigationStatus = .inProgress
                setPathfindingEnabled(true, duration: 0.2, force: true)
            }
            // Add navigation route for these pins
            updateNavigationRoute(
                with: pointList,
                at: 1,
                using: nil,
                renderPinsRequest: renderPinsRequest
            )
        } else {
            // Reset navigation session state if no valid pins
            indoorNavigationService.resetNavigationSessionState()
        }

        // Update navigation button state
        refreshNavigationState(withPins: pins)
    }
}

internal extension StoreMapLoaderViewModel {
    // Handles the rendering and navigation logic for aisle pins
    func handlePinRenderedMessage(_ pinRenderedMessage: PinRenderedMessage) {
        // Log the received message
        Log.debug("Aisle pin rendered: \(pinRenderedMessage)")

        guard !self.isPinDistanceFetched else {
            self.isPinDistanceFetched = false
            pinLocationFetchCompletionHandler?(pinRenderedMessage)
            return
        }

        // Report analytics/status for the pins
        reportPinAisleStatusEvent(for: pinRenderedMessage.pins ?? [])
        renderFeatureLocationPinsIfNeeded(for: pinRenderedMessage)
        updateNavigationServicesIfNeeded(for: pinRenderedMessage)
        updateStaticPathIfNeeded(for: pinRenderedMessage)
        processPinRenderFlow(
            pins: pinRenderedMessage.pins,
            topLeft: pinRenderedMessage.topLeft,
            bottomRight: pinRenderedMessage.bottomRight,
            isStaticPathVisible: isStaticPathVisible
        )
    }

    // Handles the rendering and navigation logic for XY pins
    func handlePinXYRenderedMessage(_ message: PinXYRenderedMessage) {
        // Log the received message
        Log.debug("XY pin rendered: \(message)")

        // Get all pins from message (xyLocationPins or pins)
        let allPins = (message.xyLocationPins?.isEmpty == false ? message.xyLocationPins : message.pins) ?? []
        processXYPinRenderFlow(
            pins: allPins,
            topLeft: message.topLeft,
            bottomRight: message.bottomRight
        )
    }

    private func processPinRenderFlow(
        pins: [Pin]?,
        topLeft: Point?,
        bottomRight: Point?,
        isStaticPathVisible: Bool
    ) {
        guard let pins, !pins.isEmpty else {
            mapViewDelegate?.refreshNavigationButtonState(false)
            return
        }

        // When static path is visible, only update static path (navigation handled elsewhere)
        if !isStaticPathVisible {
            zoomOnLocation(topLeft: topLeft, bottomRight: bottomRight)
        }
    }

    private func processXYPinRenderFlow(
        pins: [DrawPin],
        topLeft: Point?,
        bottomRight: Point?
    ) {
        guard !pins.isEmpty else {
            // Hide navigation button if no pins
            mapViewDelegate?.refreshNavigationButtonState(false)
            return
        }

        // Reset navigation waypoints
        indoorNavigationService.resetWaypoints(shouldClearBlueDot: false, shouldClearPinList: true)

        // Filter pins that are valid
        let validPins = pins.filter { $0.errorData == nil }
        let hasValidPin = !validPins.isEmpty

        // Only update if navigation is not in progress
        let shouldUpdatePinList = indoorNavigationService.navigationSessionState?.navigationStatus != .inProgress

        // Prepare pin list if needed
        let currentPinList = shouldUpdatePinList ? PinList(pins: validPins) : nil

        // Update navigation state with new pins
        indoorNavigationService.updateNavigationState(
            currentLocation: nil,
            pinWaypoint: nil,
            renderRequest: nil,
            pinListUpdate: currentPinList
        )

        mapViewDelegate?.handleNavigationInterruption(for: 1, status: navigationSessionState?.navigationStatus)

        // If there are valid pins
        if hasValidPin {
            // Add navigation route for these pins
            let pointList = validPins.map { Point(x: $0.x, y: $0.y) }
            updateNavigationRoute(
                with: pointList,
                at: 1,
                using: currentPinList,
                renderPinsRequest: nil
            )
        } else {
            // Reset navigation session state if no valid pins
            indoorNavigationService.resetNavigationSessionState()
        }

        // Update navigation button state
        refreshNavigationState(withDrawPins: pins)

        // Zoom to pin area
        zoomOnLocation(topLeft: topLeft, bottomRight: bottomRight)
    }
}

extension StoreMapLoaderViewModel: IndoorNavigationServiceDelegate {
    func requestRenderPins(_ pins: [Pin]?, pinList: PinList?, navigationEvent: NavigationAnalytics.Event?) {
        if let pins = pins {
            request(.renderPins(.init(pins: pins, pinGroupingEnabled: pinsConfig.groupPinsEnabled)))

            guard let position = indoorPositioningService.lastPosition.value,
                  position.isLocked else {
                Log.info("[Navigation] The value of lastLockedPosition is nil")
                return
            }

            guard let converter = indoorPositioningService.floorCoordinatesConverter else {
                Log.info("[Navigation] The value of floorCoordinatesConverter is nil")
                return
            }

            let compassPosition = position.convertToCompass(using: converter).asCGPoint()

            let payload = NavigationAnalytics(
                event: navigationEvent,
                location: NavigationAnalytics.Location(x: compassPosition.x, y: compassPosition.y)
            )

            Analytics.mapNavigation(payload: payload)
        } else if let pinList = pinList {
            request(.renderXYLocationPinRequested(pinList))
        }
    }

    func refreshNavigationButtonState(_ isVisible: Bool?) {
        mapViewDelegate?.refreshNavigationButtonState(isVisible)
    }
}
